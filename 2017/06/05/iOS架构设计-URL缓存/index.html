<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8"/>
    <meta http-equiv="X-UA-Compatible" content="IE=edge"/>
    
    <title>iOS架构设计-URL缓存 | Kenshin Cui&#39;s Blog</title>
    <meta name="renderer" content="webkit">
    <meta name="HandheldFriendly" content="True">
    <meta name="MobileOptimized" content="320">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

    <meta name="description" content="iOS Developer">

    <meta name="twitter:card" content="summary">
    <meta name="twitter:title" content="iOS架构设计-URL缓存 | Kenshin Cui&#39;s Blog">
    <meta name="twitter:description" content="iOS Developer">

    <meta property="og:type" content="article">
    <meta property="og:title" content="iOS架构设计-URL缓存 | Kenshin Cui&#39;s Blog">
    <meta property="og:description" content="iOS Developer">

    
    <meta name="author" content="Kenshin Cui">
    
    <link rel="stylesheet" href="/css/vno.css">
    <link rel="stylesheet" href="//netdna.bootstrapcdn.com/font-awesome/4.1.0/css/font-awesome.min.css">

    
    <link rel="icon" href="/favicon.ico">
    

    <meta name="generator" content="hexo"/>
    

    <link rel="canonical" href="http://yoursite.com/2017/06/05/iOS架构设计-URL缓存/"/>

                 
</head>

<body class="home-template no-js">
    <script src="//cdn.bootcss.com/jquery/2.1.4/jquery.min.js"></script>
    <script src="/js/main.js"></script>
    <span class="mobile btn-mobile-menu">
        <i class="fa fa-list btn-mobile-menu__icon"></i>
        <i class="fa fa-angle-up btn-mobile-close__icon hidden"></i>
    </span>

    
<header class="panel-cover panel-cover--collapsed" style="background-image: url(/images/background-cover.jpg)">
  <div class="panel-main">
    <div class="panel-main__inner panel-inverted">
    <div class="panel-main__content">

        <a href="/" title="前往 Kenshin Cui&#39;s Blog 的主页"><img src="/images/avatar.jpg" width="80" alt="Kenshin Cui&#39;s Blog logo" class="panel-cover__logo logo" /></a>
        <h1 class="panel-cover__title panel-title"><a href="/" title="link to homepage for Kenshin Cui&#39;s Blog">Kenshin Cui&#39;s Blog</a></h1>
        
        <span class="panel-cover__subtitle panel-subtitle">即便是别人看不到的地方, 对其工艺也必须尽心尽力。</span>
        
        <hr class="panel-cover__divider" />
        <p class="panel-cover__description">iOS Developer</p>
        <hr class="panel-cover__divider panel-cover__divider--secondary" />

        <div class="navigation-wrapper">
          <div>
          <nav class="cover-navigation cover-navigation--primary">
            <ul class="navigation">
              <li class="navigation__item"><a href="/#blog" title="访问博客" class="blog-button">博客</a></li>
            
              <li class="navigation__item"><a href="/archive">归档</a></li>
            
              <li class="navigation__item"><a href="/about">关于</a></li>
            
            </ul>
          </nav>
          </div>
          <div>
          <nav class="cover-navigation navigation--social">
  <ul class="navigation">

  <!-- Weibo-->
  

  <!-- Github -->
  
  <li class="navigation__item">
    <a href="https://github.com/kenshincui" title="查看我的GitHub主页" target="_blank">
      <i class='social fa fa-github'></i>
      <span class="label">Github</span>
    </a>
  </li>


<!-- Stack Overflow -->
        

  <!-- Google Plus -->
  

<!-- Facebook -->

  
<!-- Twitter -->

  



  </ul>
</nav>

          </div>
        </div>

      </div>

    </div>

    <div class="panel-cover--overlay cover-green"></div>
  </div> 
</header>

    <div class="content-wrapper">
        <div class="content-wrapper__inner">
            <article class="post-container post-container--single">

  <header class="post-header">
    <div class="post-meta">
      <time datetime="2017-06-05T07:53:20.000Z" class="post-list__meta--date date">2017-06-05</time> &#8226; <span class="post-meta__tags tags">于&nbsp;
  <a class="tag-link" href="/tags/NSURLCache-AlamofireURLCache-NSURLProtocol/">NSURLCache,AlamofireURLCache,NSURLProtocol</a>
 </span>
      <span class="page-pv">
      &nbsp;阅读&nbsp;<span id="busuanzi_value_page_pv"><i class="fa fa-spinner fa-spin"></i></span>
      </span> 
   
    </div>
    <h1 class="post-title">iOS架构设计-URL缓存</h1>
  </header>

  <section class="post">
    <h1 id="概览"><a href="#概览" class="headerlink" title="概览"></a>概览</h1><p>缓存组件应该说是每个客户端程序必备的核心组件，试想对于每个界面的访问都必须重新请求势必降低用户体验。但是如何处理客户端缓存貌似并没有统一的解决方案，多数开发者选择自行创建数据库直接将服务器端请求的JSON（或Model）缓存起来，下次请求则查询数据库检查缓存是否存在；另外还有些开发者会选择以归档文件的方式保存缓存数据，每次请求资源之前检查相应的缓存文件。事实上iOS系统自身就提供了一套缓存机制，本文将结合URL Loading System介绍一下如何利用系统自身缓存设计来实现一套缓存机制，使用这套缓存设计你无需自己编写内存和磁盘存储，无需自行检查缓存过期策略就能轻松实现数据缓存。</p>
<h1 id="URL-Loading-System"><a href="#URL-Loading-System" class="headerlink" title="URL Loading System"></a>URL Loading System</h1><p><a href="https://developer.apple.com/library/content/documentation/Cocoa/Conceptual/URLLoadingSystem/URLLoadingSystem.html" target="_blank" rel="external">URL Loading System</a>是类和协议的集合，使用URL Loading System iOS系统和服务器端进行网络交互。<strong>URL</strong>作为其中的核心，能够让app和资源进行轻松的交互。为了增强URL的功能Foundation提供了丰富的类集合，能够让你根据地址加载资源、上传资源到服务器、管理cookie、控制响应缓存（<em>这也是我们今天的重点内容</em>）、处理证书和认证、扩展用户协议（<em>后面也会提到相关内容</em>）等，因此URL缓存之前熟悉URL Loading System是必要的。下图一系列集合的关系：</p>
<p><img src="/media/nsobject_hierarchy_2x.png" alt="URL_Loading_System" style="max-width:750px"></p>
<blockquote>
<p>本文代码一律使用Swift编写，但是鉴于很多朋友接触URL Loading System都是从Objective-C开始，所以文章中文字部分还是采用OC命名，其区别不大，主要是少了<em>NS</em>前缀。</p>
</blockquote>
<p>##NSURLProtocol</p>
<p>URL Loading System默认支持http、https、ftp、file和data 协议，但是它同样也支持你注册自己的类来支持更多应用层网络协议，当然你也可以指定其他属性到URL reqeust和URL response上。具体而言NSURLProtocl可以实现以下需求（包含但不限）：</p>
<ul>
<li>重定向网络请求（或进行域名转化、拦截等，例如：<a href="https://github.com/kasketis/netfox" target="_blank" rel="external">netfox</a>）</li>
<li>忽略某些请求，使用本地缓存数据</li>
<li>自定义网络请求的返回结果 （比如：<a href="https://github.com/hypoyao/GYHttpMock" target="_blank" rel="external">GYHttpMocking</a>）</li>
<li>进行网络全局配置</li>
</ul>
<p>NSURLProtocol类似中间人设计，将网络求细节提供给开发者，而又以一种优雅的方式暴漏出来。NSURLProtocol的定义更像是一个URL协议，尽管它继承自NSObject却不能直接使用，使用时自定义协议继承NSURLProtocol，然后在app启动时注册即可，这样一来所有请求细节开发者只需要在自己的类中控制即可（这个设计确实完美👍）。</p>
<h3 id="解决DNS劫持"><a href="#解决DNS劫持" class="headerlink" title="解决DNS劫持"></a>解决DNS劫持</h3><p>随着互联网的发展，运营商劫持这些年逐渐被大家所提及，常见的劫持包括HTTP劫持和DNS劫持。对于HTTP劫持更多的是篡改网络响应加入一些脚本广告之类的内容，解决这个问题只需要使用https加密请求交互内容；而对于DNS劫持则更加可恶，在DNS解析时让请求重新定向到一个非预期IP从而达到内容篡改。</p>
<p>解决DNS劫持普遍的做法就是将URL从域名替换成IP，这么一来访问内容并不经过运营商的Local DNS而到达指定的服务器，因此也就避免了DNS劫持问题。当然，域名和IP的对应要通常通过服务器下发保证获取最近的资源节点（当然也可以采用一些收费的HTTPDNS服务），不过这样一来操作却不得不依赖于具体请求，而使用自定义NSURLProtocol的方式则可以彻底解决具体依赖问题，不管是使用NSURLConnection、NSURLSession、AFNetworking还是UIWebView(注意WKWebView有所不同)，所有的替换操作都可以统一进行控制。</p>
<p>下面的demo中自定义协议<strong>MyURLProtocol</strong>实现了将域名转化成IP进行请求的过程：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> UIKit</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyURLProtocol</span>: <span class="title">URLProtocol</span></span>&#123;</span><br><span class="line">    <span class="comment">// MARK: - URLProtocol虚方法实现</span></span><br><span class="line">    <span class="comment">// 是否处理对应的请求</span></span><br><span class="line">    <span class="keyword">override</span> <span class="class"><span class="keyword">class</span> <span class="title">func</span> <span class="title">canInit</span>(<span class="title">with</span> <span class="title">request</span>: <span class="title">URLRequest</span>) -&gt; <span class="title">Bool</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> <span class="type">URLProtocol</span>.property(forKey: <span class="type">MyURLProtocol</span>.<span class="type">PropertyKey</span>.tagKey, <span class="keyword">in</span>: request) != <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回请求，在此方法中可以修改请求</span></span><br><span class="line">    <span class="keyword">override</span> <span class="class"><span class="keyword">class</span> <span class="title">func</span> <span class="title">canonicalRequest</span>(<span class="title">for</span> <span class="title">request</span>: <span class="title">URLRequest</span>) -&gt; <span class="title">URLRequest</span> </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> newRequest = request</span><br><span class="line">        <span class="comment">// 例如这里域名为指定ip，实际开发中应该从服务器下方domain list</span></span><br><span class="line">        <span class="keyword">let</span> originHost = request.url?.host</span><br><span class="line">        <span class="keyword">if</span> <span class="string">"baidu.com"</span> == originHost &#123;</span><br><span class="line">            <span class="keyword">let</span> originURL = request.url?.absoluteString</span><br><span class="line">            <span class="keyword">let</span> newURL = originURL?.replacingOccurrences(of: originHost!, with: <span class="string">"61.135.169.121"</span>)</span><br><span class="line">            newRequest.url = <span class="type">URL</span>(string: newURL!)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> newRequest</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 开始加载</span></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">startLoading</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">guard</span> <span class="keyword">let</span> newRequest = (request <span class="keyword">as</span> <span class="type">NSURLRequest</span>).mutableCopy() <span class="keyword">as</span>? <span class="type">NSMutableURLRequest</span> <span class="keyword">else</span> &#123; <span class="keyword">return</span>&#125;</span><br><span class="line">        <span class="type">URLProtocol</span>.setProperty(<span class="literal">true</span>, forKey: <span class="type">MyURLProtocol</span>.<span class="type">PropertyKey</span>.tagKey, <span class="keyword">in</span>: newRequest)</span><br><span class="line">        <span class="keyword">let</span> sessionConfig = <span class="type">URLSessionConfiguration</span>.<span class="keyword">default</span></span><br><span class="line">        <span class="keyword">let</span> urlSession = <span class="type">URLSession</span>(configuration: sessionConfig, delegate: <span class="keyword">self</span>, delegateQueue: <span class="literal">nil</span>)</span><br><span class="line">        <span class="keyword">self</span>.dataTask = urlSession.dataTask(with: <span class="keyword">self</span>.request)</span><br><span class="line">        <span class="keyword">self</span>.dataTask?.resume()</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 停止加载</span></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">stopLoading</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">self</span>.dataTask?.cancel()</span><br><span class="line">        <span class="keyword">self</span>.dataTask       = <span class="literal">nil</span></span><br><span class="line">        <span class="keyword">self</span>.receivedData   = <span class="literal">nil</span></span><br><span class="line">        <span class="keyword">self</span>.urlResponse    = <span class="literal">nil</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 判断两个请求是否相等，相等则考虑使用缓存，此方法不是必须实现</span></span><br><span class="line">    <span class="keyword">override</span> <span class="class"><span class="keyword">class</span> <span class="title">func</span> <span class="title">requestIsCacheEquivalent</span>(_ <span class="title">a</span>: <span class="title">URLRequest</span>, <span class="title">to</span> <span class="title">b</span>: <span class="title">URLRequest</span>) -&gt; <span class="title">Bool</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.requestIsCacheEquivalent(a, to: b)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    <span class="comment">// MARK: - 私有属性</span></span><br><span class="line">    <span class="keyword">private</span> <span class="class"><span class="keyword">struct</span> <span class="title">MyURLProtocolKey</span> </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> tagKey = <span class="string">"MyURLProtocolTagKey"</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    fileprivate <span class="keyword">var</span> dataTask: <span class="type">URLSessionDataTask</span>?</span><br><span class="line">    fileprivate <span class="keyword">var</span> urlResponse: <span class="type">URLResponse</span>?</span><br><span class="line">    fileprivate <span class="keyword">var</span> receivedData: <span class="type">NSMutableData</span>?</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">MyURLProtocol</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">PropertyKey</span></span>&#123;</span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">var</span> tagKey = <span class="string">"MyURLProtocolTagKey"</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 注意实际开发中应该尽可能处理所有self.client?.urlProtocol回传方法，以免客户端有些方法无法做出响应</span></span><br><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">MyURLProtocol</span>:<span class="title">URLSessionTaskDelegate</span>,<span class="title">URLSessionDataDelegate</span> </span>&#123;</span><br><span class="line">    <span class="comment">// MARK: - URLSessionDataDelegate方法</span></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">urlSession</span><span class="params">(<span class="number">_</span> session: URLSession, dataTask: URLSessionDataTask, didReceive response: URLResponse, completionHandler: @escaping <span class="params">(URLSession.ResponseDisposition)</span></span></span> -&gt; <span class="type">Void</span>) &#123;</span><br><span class="line">        <span class="keyword">self</span>.client?.urlProtocol(<span class="keyword">self</span>, didReceive: response, cacheStoragePolicy: .notAllowed)</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">self</span>.urlResponse = response</span><br><span class="line">        <span class="keyword">self</span>.receivedData = <span class="type">NSMutableData</span>()</span><br><span class="line">        </span><br><span class="line">        completionHandler(.allow)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">urlSession</span><span class="params">(<span class="number">_</span> session: URLSession, dataTask: URLSessionDataTask, didReceive data: Data)</span></span> &#123;</span><br><span class="line">        <span class="keyword">self</span>.client?.urlProtocol(<span class="keyword">self</span>, didLoad: data <span class="keyword">as</span> <span class="type">Data</span>)</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">self</span>.receivedData?.append(data <span class="keyword">as</span> <span class="type">Data</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// URLSessionTaskDelegate</span></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">urlSession</span><span class="params">(<span class="number">_</span> session: URLSession, task: URLSessionTask, didCompleteWithError error: Error?)</span></span> &#123;</span><br><span class="line">        <span class="keyword">if</span> error != <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="keyword">self</span>.client?.urlProtocol(<span class="keyword">self</span>, didFailWithError: error!)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//saveCachedResponse()</span></span><br><span class="line">            <span class="keyword">self</span>.client?.urlProtocolDidFinishLoading(<span class="keyword">self</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意使用URLSession进行网络请求时如果使用的不是默认会话（URLSession.shared）则需要在URLSessionConfiguration中指定<strong>protocolClasses</strong>自定义URLProtocol才能进行处理（即使使用URLProtocol.registerClass进行注册），URLSession.shared默认则可以响应已注册URLProtocol。<br>在MyURLProtocol的<strong>startLoading</strong>方法内同样发起了URL请求，如果此时使用了URLSession.shared进行网络请求则同样会造成MyURLProtocol调用，如此会引起循环调用。考虑到<strong>startLoading</strong>方法能可能是NSURLConnnection实现，安全起见在MyURLProtocol内部使用<strong>URLProtocol.setProperty(true, forKey: MyCacheURLProtocolTagKey, in: newRequest)</strong>来标记一个请求，调用前使用<strong>URLProtocol.property(forKey: MyCacheURLProtocolTagKey, in: request)</strong>判断当前请求是否已经标记，如果已经标记则视为同一请求，MyURLProtocol则不再处理，从而避免同一个请求循环调用。</p>
<blockquote>
<p>如果你的网络请求使用的NSURLConnection，上面的代码需要做相应修改，但相信现在NSURLConnection使用应该越来越少了，很多第三方网络库也不支持了。</p>
</blockquote>
<h3 id="NSURLProtocol缓存"><a href="#NSURLProtocol缓存" class="headerlink" title="NSURLProtocol缓存"></a>NSURLProtocol缓存</h3><p>其实无论是NSURLConnection、NSURLSession还是UIWebView、WKWebView默认都是有缓存设计的（使用NSURLCache，后面会着重介绍），不过这要配合服务器端response header使用，对于有缓存的页面（或者API接口），当缓存过期后，默认情况下（NSURLRequestUseProtocolCachePolicy）遇到同一个请求则通常会发出一个header中包含<strong>If-Modified-Since</strong>的请求到服务器端验证，如果内容没有过期则返回一个不含有body的响应（Response code为304），客户端使用缓存数据，否则重新返回新的数据。</p>
<p>由于WKWebView默认有几十秒的缓存时间，在第一次缓存响应后过一段时间才会进行缓存请求检查（缓存过期后才会发送包含<strong>If-Modified-Since</strong>的请求检查）。但是这并不是说自己设计缓存就完全没有必要，第一它做不到完全的离线后阅读（尽管在一定时间内不需要检查，但是过一段时间还是需要联网检查的），第二无法做到缓存细节的控制。</p>
<p>下面简单利用NSURLProtocol来实现WKWebView的离线缓存功能，不过需要注意的是WKWebView默认仅仅调用NSURLProtocol的<strong>canInitWithRequest:</strong>方法，如果要真正利用NSURLProtocol进行缓存还必须使用WKBrowsingContextController的registerSchemeForCustomProtocol进行注册，不过这是个私有对象，需要使用黑魔法。下面的demo中简单实现了WKWebView的离线缓存功能，有了它之后遇到访问过的资源即使没有网络也同样可以访问。当然，示例主要用以说明缓存的原理，实际开发中还有很多问题需要思考，比如说缓存过期机制、磁盘缓存保存方式等等。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> UIKit</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyCacheURLProtocol</span>: <span class="title">URLProtocol</span></span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// MARK: - URLProtocol虚方法实现</span></span><br><span class="line">    <span class="comment">// 是否处理对应的请求</span></span><br><span class="line">    <span class="keyword">override</span> <span class="class"><span class="keyword">class</span> <span class="title">func</span> <span class="title">canInit</span>(<span class="title">with</span> <span class="title">request</span>: <span class="title">URLRequest</span>) -&gt; <span class="title">Bool</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> <span class="type">URLProtocol</span>.property(forKey: <span class="type">MyCacheURLProtocol</span>.<span class="type">PropertyKey</span>.tagKey, <span class="keyword">in</span>: request) != <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 返回请求，在此方法中可以修改请求</span></span><br><span class="line">    <span class="keyword">override</span> <span class="class"><span class="keyword">class</span> <span class="title">func</span> <span class="title">canonicalRequest</span>(<span class="title">for</span> <span class="title">request</span>: <span class="title">URLRequest</span>) -&gt; <span class="title">URLRequest</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> request</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 开始加载</span></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">startLoading</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="function"><span class="keyword">func</span> <span class="title">sendRequest</span><span class="params">()</span></span> &#123;</span><br><span class="line">            <span class="keyword">guard</span> <span class="keyword">let</span> newRequest = (request <span class="keyword">as</span> <span class="type">NSURLRequest</span>).mutableCopy() <span class="keyword">as</span>? <span class="type">NSMutableURLRequest</span> <span class="keyword">else</span> &#123; <span class="keyword">return</span>&#125;</span><br><span class="line">            <span class="type">URLProtocol</span>.setProperty(<span class="literal">true</span>, forKey: <span class="type">MyCacheURLProtocol</span>.<span class="type">PropertyKey</span>.tagKey, <span class="keyword">in</span>: newRequest)</span><br><span class="line">            <span class="keyword">let</span> sessionConfig = <span class="type">URLSessionConfiguration</span>.<span class="keyword">default</span></span><br><span class="line">            <span class="keyword">let</span> urlSession = <span class="type">URLSession</span>(configuration: sessionConfig, delegate: <span class="keyword">self</span>, delegateQueue: <span class="literal">nil</span>)</span><br><span class="line">            <span class="keyword">self</span>.dataTask = urlSession.dataTask(with: <span class="keyword">self</span>.request)</span><br><span class="line">            <span class="keyword">self</span>.dataTask?.resume()</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">let</span> cacheResponse = <span class="keyword">self</span>.getResponse() &#123;</span><br><span class="line">            <span class="keyword">self</span>.client?.urlProtocol(<span class="keyword">self</span>, didReceive: cacheResponse.response, cacheStoragePolicy: .notAllowed)</span><br><span class="line">            <span class="keyword">self</span>.client?.urlProtocol(<span class="keyword">self</span>, didLoad: cacheResponse.data)</span><br><span class="line">            <span class="keyword">self</span>.client?.urlProtocolDidFinishLoading(<span class="keyword">self</span>)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            sendRequest()</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 停止加载</span></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">stopLoading</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">self</span>.dataTask?.cancel()</span><br><span class="line">        <span class="keyword">self</span>.dataTask       = <span class="literal">nil</span></span><br><span class="line">        <span class="keyword">self</span>.receivedData   = <span class="literal">nil</span></span><br><span class="line">        <span class="keyword">self</span>.urlResponse    = <span class="literal">nil</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 判断两个请求是否相等，相等则考虑使用缓存，此方法不是必须实现</span></span><br><span class="line">    <span class="keyword">override</span> <span class="class"><span class="keyword">class</span> <span class="title">func</span> <span class="title">requestIsCacheEquivalent</span>(_ <span class="title">a</span>: <span class="title">URLRequest</span>, <span class="title">to</span> <span class="title">b</span>: <span class="title">URLRequest</span>) -&gt; <span class="title">Bool</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.requestIsCacheEquivalent(a, to: b)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="comment">// MARK: - 私有方法</span></span><br><span class="line">    fileprivate <span class="function"><span class="keyword">func</span> <span class="title">saveResponse</span><span class="params">(<span class="number">_</span> response:URLResponse,<span class="number">_</span> data:Data)</span></span> &#123;</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">let</span> key = <span class="keyword">self</span>.request.url?.absoluteString &#123;</span><br><span class="line">            <span class="keyword">let</span> tempDic = <span class="type">NSTemporaryDirectory</span>() <span class="keyword">as</span> <span class="type">NSString</span></span><br><span class="line">            <span class="keyword">let</span> filePath = tempDic.appendingPathComponent(key.md5())</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">let</span> cacheResponse = <span class="type">CachedURLResponse</span>(response: response, data: data, userInfo: <span class="literal">nil</span>, storagePolicy: <span class="type">URLCache</span>.<span class="type">StoragePolicy</span>.notAllowed)</span><br><span class="line">            <span class="type">NSKeyedArchiver</span>.archiveRootObject(cacheResponse, toFile: filePath)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    fileprivate <span class="function"><span class="keyword">func</span> <span class="title">getResponse</span><span class="params">()</span></span> -&gt; <span class="type">CachedURLResponse</span>? &#123;</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">let</span> key = <span class="keyword">self</span>.request.url?.absoluteString &#123;</span><br><span class="line">            <span class="keyword">let</span> tempDic = <span class="type">NSTemporaryDirectory</span>() <span class="keyword">as</span> <span class="type">NSString</span></span><br><span class="line">            <span class="keyword">let</span> filePath = tempDic.appendingPathComponent(key.md5())</span><br><span class="line">            <span class="keyword">if</span> <span class="type">FileManager</span>.<span class="keyword">default</span>.fileExists(atPath: filePath) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="type">NSKeyedUnarchiver</span>.unarchiveObject(withFile: filePath) <span class="keyword">as</span>? <span class="type">CachedURLResponse</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// MARK: - 私有属性</span></span><br><span class="line">    fileprivate <span class="keyword">var</span> dataTask: <span class="type">URLSessionDataTask</span>?</span><br><span class="line">    fileprivate <span class="keyword">var</span> urlResponse: <span class="type">URLResponse</span>?</span><br><span class="line">    fileprivate <span class="keyword">var</span> receivedData: <span class="type">NSMutableData</span>?</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">MyCacheURLProtocol</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">PropertyKey</span></span>&#123;</span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">var</span> tagKey = <span class="string">"MyURLProtocolTagKey"</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 注意实际开发中应该尽可能处理所有self.client?.urlProtocol回传方法，以免客户端有些方法无法做出响应</span></span><br><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">MyCacheURLProtocol</span>:<span class="title">URLSessionTaskDelegate</span>,<span class="title">URLSessionDataDelegate</span> </span>&#123;</span><br><span class="line">    <span class="comment">// MARK: - URLSessionDataDelegate方法</span></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">urlSession</span><span class="params">(<span class="number">_</span> session: URLSession, dataTask: URLSessionDataTask, didReceive response: URLResponse, completionHandler: @escaping <span class="params">(URLSession.ResponseDisposition)</span></span></span> -&gt; <span class="type">Void</span>) &#123;</span><br><span class="line">        <span class="keyword">self</span>.client?.urlProtocol(<span class="keyword">self</span>, didReceive: response, cacheStoragePolicy: .notAllowed)</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">self</span>.urlResponse = response</span><br><span class="line">        <span class="keyword">self</span>.receivedData = <span class="type">NSMutableData</span>()</span><br><span class="line">        </span><br><span class="line">        completionHandler(.allow)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">urlSession</span><span class="params">(<span class="number">_</span> session: URLSession, dataTask: URLSessionDataTask, didReceive data: Data)</span></span> &#123;</span><br><span class="line">        <span class="keyword">self</span>.client?.urlProtocol(<span class="keyword">self</span>, didLoad: data <span class="keyword">as</span> <span class="type">Data</span>)</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">self</span>.receivedData?.append(data <span class="keyword">as</span> <span class="type">Data</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// URLSessionTaskDelegate</span></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">urlSession</span><span class="params">(<span class="number">_</span> session: URLSession, task: URLSessionTask, didCompleteWithError error: Error?)</span></span> &#123;</span><br><span class="line">        <span class="keyword">if</span> error != <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="keyword">self</span>.client?.urlProtocol(<span class="keyword">self</span>, didFailWithError: error!)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">self</span>.client?.urlProtocolDidFinishLoading(<span class="keyword">self</span>)</span><br><span class="line">            <span class="comment">//save cache</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">self</span>.urlResponse != <span class="literal">nil</span> &amp;&amp; <span class="keyword">self</span>.receivedData != <span class="literal">nil</span> &#123;</span><br><span class="line">                <span class="keyword">self</span>.saveResponse(<span class="keyword">self</span>.urlResponse!, <span class="keyword">self</span>.receivedData?.copy() <span class="keyword">as</span>! <span class="type">Data</span>)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="NSURLCache"><a href="#NSURLCache" class="headerlink" title="NSURLCache"></a>NSURLCache</h2><p>事实上无论是NSURLConnection、URLSession还是UIWebView、WKWebView默认都是包含缓存的（注意WKWebView的缓存配置是从iOS 9.0开始提供的，但是其实iOS 8.0中也同样包含缓存设计，只是没有提供缓存配置接口）。对于多数开发者而言缓存设计考虑更多的是磁盘缓存（如果需要做内存缓存建议使用<a href="https://developer.apple.com/reference/foundation/nscache" target="_blank" rel="external">NSCache</a>，提供了缓存过高自动移除功能 or YYCache），而磁盘缓存设计大致可以分为API访问返回的JSON缓存（通过NSURLConnection或者NSURLSession请求标准的JSON数据）和客户端web页面缓存（UIWebView、WKWebView）。</p>
<p>NSURLConnection和UIWebView来说，默认都会使用NSURLCache，通常在应用启动中会进行NSURLCache配置，当然即使不进行配置也是有默认配置的。但二者并不是今天介绍的重点，我们重点关注NSURLSession和WKWebView。对于NSURLSession而言默认仍然会使用全局的NSURLCache(可以在启动时自己初始化，例如<code>URLCache.shared = URLCache(memoryCapacity: 5*1024*1024, diskCapacity: 20*1024*1024, diskPath: nil)</code>)，但是相比于默认NSURLConnection而言NSURLSession更加灵活，因为每个URLSessionConfiguration都可以指定独立的URLCache,默认情况下是使用一个私有内存缓存，如果设置为nil则不再使用缓存。而且还可以通过URLSessionConfiguration的requestCachePolicy属性指定缓存策略。</p>
<h3 id="缓存策略CachePolicy"><a href="#缓存策略CachePolicy" class="headerlink" title="缓存策略CachePolicy"></a>缓存策略CachePolicy</h3><ul>
<li>useProtocolCachePolicy：默认缓存策略，对于特定URL使用网络协议中实现的缓存策略。</li>
<li>reloadIgnoringLocalCacheData（或者reloadIgnoringCacheData）：不使用缓存，直接请求原始数据。</li>
<li>returnCacheDataElseLoad：无论缓存是否过期，有缓存则使用缓存，否则重新请求原始数据。</li>
<li>returnCacheDataDontLoad：无论缓存是否过期，有缓存则使用缓存，否则视为失败，不会重新请求原始数据。</li>
</ul>
<p>其实对于多数开发者而言，第二种根本不缓存，其他两种也存在着很大的使用风险，所以默认缓存策略才是我们最关心的，它使用网络协议中实现的缓存策略，那我们就应该首先弄清网络协议中的缓存策略是如何来控制的（注意：无论是NSURLConnection还是NSURLSession都支持多种协议，这里重点关注HTTP、HTTPS）。</p>
<p>HTTP的请求和响应使用headers来进行元数据交换，例如MIME、Encoding，当然也包括缓存执行，下面会着重介绍相关缓存配置。</p>
<h3 id="请求头信息-Request-cache-headers"><a href="#请求头信息-Request-cache-headers" class="headerlink" title="请求头信息 Request cache headers"></a>请求头信息 Request cache headers</h3><ul>
<li><strong>If-Modified-Since</strong>:与响应头Last-Modified相对应，其值为最后一次响应头中的Last-Modified。</li>
<li><strong>If-None-Match</strong>:与响应头Etag相对应，其值为最后一次响应头中的Etag。</li>
</ul>
<h3 id="响应头信息-Response-cache-headers"><a href="#响应头信息-Response-cache-headers" class="headerlink" title="响应头信息 Response cache headers"></a>响应头信息 Response cache headers</h3><ul>
<li><strong>Last-Modified</strong>:资源最近修改时间</li>
<li><strong>Etag</strong>:（Entity tag缩写）是请求资源的标识符，主要用于动态生成、没有Last-Modified值的资源。</li>
<li><strong>Cache-Control</strong>:缓存控制，只有包含此设置可能使用默认缓存策略。可能包含如下选项：<br>  <strong>max-age</strong>：缓存时间（单位：秒）。<br>  <strong>public</strong>：可以被任何区缓存，包括中间经过的代理服务器也可以缓存。通常不会被使用，因为    max-age已经表示此响应可以缓存。<br>  <strong>private</strong>:只能被当前客户端缓存，中间代理无法进行缓存。<br>  <strong>no-cache</strong>:必须与服务器端确认响应是否发生了变化，如果没有变化则可以使用缓存，否则使用新请求的响应。<br>  <strong>no-store</strong>:禁止使用缓存</li>
<li><strong>Vary</strong>:决定如何决定请求是否可以使用缓存，通常用于缓存key唯一值确定因素，同一个资源不同的Vary设置会被作为两个缓存资源（注意，NSURLCache会忽略Vary请求缓存）。</li>
</ul>
<blockquote>
<p>注意：Expires是HTTP 1.0标准缓存控制，不建议使用，请使用<em>Cache-Control:max-age</em>代替，类似的还有Pragma:no-cache和Cache-Control:no-cache。此外，Request cache headers中也是可以包含Cache-Control的，例如如果设置为no-cache则说明此次请求不要使用缓存数据作为响应。</p>
</blockquote>
<p>默认缓存策略下当客户端发起一个请求时首先会检查本地是否包含缓存，如果有缓存则继续检查缓存是否过期（通过<em>Cache-Control:max-age</em>或者<em>Expires</em>），如果没有过期则直接使用缓存数据。如果缓存过期了，则发起一个请求给服务器端，此时服务器端对比资源<em>Last-Modified</em>或者<em>Etags</em>(二者都存在的情况下下如果有一个不同则认为缓存已过期)，如果不同则返回新数据，否则返回<em>304 Not Modified</em>继续使用缓存数据（客户端可以再使用”max-age”秒缓存数据）。在这个过程中可以发现，客户端发送不发送请求主要看<em>max-age</em>是否过期，而过期后是否继续访问则需要重新发起请求，服务器端根据情况通知客户端是否可以继续使用缓存（这个过程是必须请求的，只是返回结果可能是200或者304）。</p>
<p>清楚了默认网络协议缓存相关的设置之后，要使用默认缓存就很简单了，通常对于NSURLSession你不做任何设置，只要服务器端响应头部加上Cache-Control:max-age:xxx就可以使用缓存了。下面Demo3中演示了如何使用使用NSURLSession通过max-age进行为期60s的缓存，运行会发现在第一次请求之后60s内不会进行再次请求，60s后才会发起第二次请求。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> config = <span class="type">URLSessionConfiguration</span>.<span class="keyword">default</span></span><br><span class="line"><span class="comment">// urlCache默认使用私有内存缓存</span></span><br><span class="line"><span class="comment">// config.urlCache = URLCache(memoryCapacity: 5*1024*1024, diskCapacity: 20*1024*1024, diskPath: nil)</span></span><br><span class="line"><span class="comment">// config.requestCachePolicy = .useProtocolCachePolicy</span></span><br><span class="line"><span class="keyword">let</span> urlSession = <span class="type">URLSession</span>(configuration: config)</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">let</span> url = <span class="type">URL</span>(string: <span class="string">"http://myapi.applinzi.com/url-cache/default-cache.php"</span>) &#123;</span><br><span class="line">            <span class="keyword">let</span> dataTask = urlSession.dataTask(with: url, completionHandler: &#123; (data, response, error) <span class="keyword">in</span></span><br><span class="line">                <span class="keyword">if</span> <span class="keyword">let</span> tempError = error &#123;</span><br><span class="line">                    <span class="built_in">debugPrint</span>(tempError)</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">guard</span> <span class="keyword">let</span> tempData = data <span class="keyword">else</span> &#123; <span class="keyword">return</span> &#125;</span><br><span class="line">                    <span class="keyword">let</span> responseText = <span class="type">String</span>(data: tempData, encoding: <span class="type">String</span>.<span class="type">Encoding</span>.utf8)</span><br><span class="line">                    <span class="built_in">debugPrint</span>(responseText ?? <span class="string">"no text"</span>)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;)</span><br><span class="line">            </span><br><span class="line">            dataTask.resume()</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>
<p>服务器端default-cache.php内容如下：</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">	$time=time();</span><br><span class="line">	$interval=<span class="number">60</span>;</span><br><span class="line">	header(<span class="string">'Last-Modified: '</span>.gmdate(<span class="string">'r'</span>,$time));</span><br><span class="line">	header(<span class="string">'Expires: '</span>.gmdate(<span class="string">'r'</span>,($time+$interval)));</span><br><span class="line">	header(<span class="string">'Cache-Control: max-age='</span>.$interval);</span><br><span class="line">	header(<span class="string">'Content-type: text/json'</span>);</span><br><span class="line"></span><br><span class="line">	$arr = <span class="keyword">array</span>(<span class="string">'a'</span>=&gt;<span class="number">1</span>,<span class="string">'b'</span>=&gt;<span class="number">2</span>);</span><br><span class="line"> 	<span class="keyword">echo</span> json_encode($arr);</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>
<p>对应的请求和相应头信息如下,服务器端设置缓存60s：</p>
<p><img src="/media/URLSession_DefaultCache_Headers.png" alt="URLSession_DefaultCache_Headers"></p>
<p>当然，配合服务器端使用缓存是一种不错的方案，自然官方设计时也是希望尽可能使用默认缓存策略。但是有些时候服务器端出于其他原因考虑，或者说或客户端需要自定义缓存策略时还是有必要进行手动缓存管理的。比如说如果服务器端根本没有设置缓存过期时间或者服务器端根本无法获知用户何时清理缓存、何时使用缓存这些具体逻辑等都需要服务器端自行制定缓存策略。有不少朋友选择自建数据库直接缓存JSON模型（通常是NSArray或者NSDictionary）或者缓存成归档文件等，其实使用NSURLCache默认的缓存策略依然可行，只是需要使用相关的代理方法、控制缓存逻辑：</p>
<p>对于NSURLConnnection而言可以通过<code>- (NSCachedURLResponse *)connection:(NSURLConnection *)connection  willCacheResponse:(NSCachedURLResponse *)cachedResponse</code>进行二次缓存设置，如果此方法返回nil则不进行缓存，默认不实现这个代理则会走默认缓存策略。而URLSessionDataDelegate也有一个类似的方法是<code>func urlSession(_ session: URLSession, dataTask: URLSessionDataTask, willCacheResponse proposedResponse: CachedURLResponse, completionHandler: @escaping (CachedURLResponse?) -&gt; Swift.Void)</code>，它的使用和NSURLConnection是类似的，不同的是<code>dataTask(with url: URL, completionHandler: @escaping (Data?, URLResponse?, Error?) -&gt; Swift.Void)</code>等一系列带有completionHandler的方法并不会走代理方法，所以这种情况下<code>func urlSession(_ session: URLSession, dataTask: URLSessionDataTask, willCacheResponse proposedResponse: CachedURLResponse, completionHandler: @escaping (CachedURLResponse?) -&gt; Swift.Void)</code>也是无法使用的，使用时需要特别注意。</p>
<p>事实上无论URLSession走缓存相关的代理，还是通过completionHandler进行回调，默认都会使用NSURLCache进行缓存，无需做任何工作。例如Demo3中的示例2、3都都打印出了默认的缓存信息，不过如果服务器端不进行缓存设置的话（header中设置Cache-Control），默认情况下NSURLSession是不会使用缓存数据的。如果将缓存策略设置为优先考虑缓存使用（例如使用：<strong>.returnCacheDataElseLoad</strong>），则可以看到下次请求不会再发送请求，Demo3中的示例4演示了这一情况。不过一旦如此设置之后以后想要更新缓存就变得艰难了，因为只要不清空缓存或超过缓存限制，缓存数据就一直存在，而且在应用中随时换切换缓存策略成本也并不低。因此，要合理利用系统默认缓存的出发点还是应该着眼在默认的基于网络协议的缓存设置，因为使用这个缓存策略基本已经很完美了。</p>
<p>不过这样一来缓存的控制逻辑就上升为解决缓存问题的重点，比如说一个API接口设计多数情况下可以缓存，但是一旦用户修改了部分信息则希望及时更新使用最新数据，但是缓存不过期服务器端即使很了解客户端设计也无法做到强制更新缓存，因此客户端就不得不自行控制缓存。那么能不能强制NSURLCache使用网络协议缓存策略呢，其实也是可以的，对于服务器端没有添加cache headers控制的响应只需要添加上响应的缓存控制即可。Demo3的示例5说明了这一点。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> UIKit</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DemoViewController3</span>: <span class="title">UIViewController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">viewDidLoad</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.viewDidLoad()</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@IBAction</span> <span class="function"><span class="keyword">func</span> <span class="title">requestWithServerCache1</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">let</span> config = <span class="type">URLSessionConfiguration</span>.<span class="keyword">default</span></span><br><span class="line">        <span class="comment">// urlCache默认使用私有内存缓存</span></span><br><span class="line">        <span class="comment">// config.urlCache = URLCache(memoryCapacity: 5*1024*1024, diskCapacity: 20*1024*1024, diskPath: nil)</span></span><br><span class="line">        <span class="comment">// config.requestCachePolicy = .useProtocolCachePolicy</span></span><br><span class="line">        <span class="keyword">let</span> urlSession = <span class="type">URLSession</span>(configuration: config)</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">let</span> url = <span class="type">URL</span>(string: <span class="string">"http://myapi.applinzi.com/url-cache/default-cache.php"</span>) &#123;</span><br><span class="line">            <span class="keyword">let</span> dataTask = urlSession.dataTask(with: url, completionHandler: &#123; (data, response, error) <span class="keyword">in</span></span><br><span class="line">                <span class="keyword">if</span> <span class="keyword">let</span> tempError = error &#123;</span><br><span class="line">                    <span class="built_in">debugPrint</span>(tempError)</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">guard</span> <span class="keyword">let</span> tempData = data <span class="keyword">else</span> &#123; <span class="keyword">return</span> &#125;</span><br><span class="line">                    <span class="keyword">let</span> responseText = <span class="type">String</span>(data: tempData, encoding: <span class="type">String</span>.<span class="type">Encoding</span>.utf8)</span><br><span class="line">                    <span class="built_in">debugPrint</span>(responseText ?? <span class="string">"no text"</span>)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;)</span><br><span class="line">            </span><br><span class="line">            dataTask.resume()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@IBAction</span> <span class="function"><span class="keyword">func</span> <span class="title">requestWithoutServerCache2</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">let</span> config = <span class="type">URLSessionConfiguration</span>.<span class="keyword">default</span></span><br><span class="line">        <span class="keyword">let</span> urlSession = <span class="type">URLSession</span>(configuration: config, delegate: <span class="keyword">self</span>.delegate, delegateQueue: <span class="literal">nil</span>)</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">let</span> url = <span class="type">URL</span>(string: <span class="string">"http://myapi.applinzi.com/url-cache/no-cache.php"</span>) &#123;</span><br><span class="line">            <span class="keyword">let</span> dataTask = urlSession.dataTask(with: url)</span><br><span class="line">            dataTask.resume()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@IBAction</span> <span class="function"><span class="keyword">func</span> <span class="title">requestWithoutServerCache3</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">let</span> config = <span class="type">URLSessionConfiguration</span>.<span class="keyword">default</span></span><br><span class="line">        <span class="keyword">let</span> urlSession = <span class="type">URLSession</span>(configuration: config, delegate: <span class="keyword">self</span>, delegateQueue: <span class="literal">nil</span>)</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">let</span> url = <span class="type">URL</span>(string: <span class="string">"http://myapi.applinzi.com/url-cache/no-cache.php"</span>) &#123;</span><br><span class="line">            <span class="keyword">let</span> urlRequest = <span class="type">URLRequest</span>(url: url)</span><br><span class="line">            <span class="keyword">let</span> dataTask = urlSession.dataTask(with: urlRequest, completionHandler: &#123; (data, response, error) <span class="keyword">in</span></span><br><span class="line">                <span class="keyword">if</span> <span class="keyword">let</span> tempError = error &#123;</span><br><span class="line">                    <span class="built_in">debugPrint</span>(tempError)</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">guard</span> <span class="keyword">let</span> tempData = data <span class="keyword">else</span> &#123; <span class="keyword">return</span> &#125;</span><br><span class="line">                    <span class="keyword">let</span> responseText = <span class="type">String</span>(data: tempData, encoding: <span class="type">String</span>.<span class="type">Encoding</span>.utf8)</span><br><span class="line">                    <span class="keyword">let</span> cacheResponse = <span class="type">URLCache</span>.shared.cachedResponse(<span class="keyword">for</span>: urlRequest)</span><br><span class="line">                    <span class="built_in">debugPrint</span>(cacheResponse)</span><br><span class="line">                    <span class="built_in">debugPrint</span>(responseText ?? <span class="string">"no text"</span>)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;)</span><br><span class="line">            </span><br><span class="line">            dataTask.resume()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@IBAction</span> <span class="function"><span class="keyword">func</span> <span class="title">requestWithoutServerCache4</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">let</span> config = <span class="type">URLSessionConfiguration</span>.<span class="keyword">default</span></span><br><span class="line">        <span class="comment">// 使用缓存数据</span></span><br><span class="line">        config.requestCachePolicy = .returnCacheDataDontLoad</span><br><span class="line">        <span class="keyword">let</span> urlSession = <span class="type">URLSession</span>(configuration: config, delegate: <span class="keyword">self</span>, delegateQueue: <span class="literal">nil</span>)</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">let</span> url = <span class="type">URL</span>(string: <span class="string">"http://myapi.applinzi.com/url-cache/no-cache.php"</span>) &#123;</span><br><span class="line">            <span class="keyword">let</span> urlRequest = <span class="type">URLRequest</span>(url: url)</span><br><span class="line">            <span class="keyword">let</span> dataTask = urlSession.dataTask(with: urlRequest, completionHandler: &#123; (data, response, error) <span class="keyword">in</span></span><br><span class="line">                <span class="keyword">if</span> <span class="keyword">let</span> tempError = error &#123;</span><br><span class="line">                    <span class="built_in">debugPrint</span>(tempError)</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">guard</span> <span class="keyword">let</span> tempData = data <span class="keyword">else</span> &#123; <span class="keyword">return</span> &#125;</span><br><span class="line">                    <span class="keyword">let</span> responseText = <span class="type">String</span>(data: tempData, encoding: <span class="type">String</span>.<span class="type">Encoding</span>.utf8)</span><br><span class="line">                    <span class="keyword">let</span> cacheResponse = <span class="type">URLCache</span>.shared.cachedResponse(<span class="keyword">for</span>: urlRequest)</span><br><span class="line">                    <span class="built_in">debugPrint</span>(cacheResponse)</span><br><span class="line">                    <span class="built_in">debugPrint</span>(responseText ?? <span class="string">"no text"</span>)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;)</span><br><span class="line">            </span><br><span class="line">            dataTask.resume()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@IBAction</span> <span class="function"><span class="keyword">func</span> <span class="title">requestWithoutServerCache5</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">let</span> config = <span class="type">URLSessionConfiguration</span>.<span class="keyword">default</span></span><br><span class="line">        <span class="keyword">let</span> urlSession = <span class="type">URLSession</span>(configuration: config, delegate: <span class="keyword">self</span>, delegateQueue: <span class="literal">nil</span>)</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">let</span> url = <span class="type">URL</span>(string: <span class="string">"http://myapi.applinzi.com/url-cache/no-cache.php"</span>) &#123;</span><br><span class="line">            <span class="keyword">let</span> dataTask = urlSession.dataTask(with: url)</span><br><span class="line">            dataTask.resume()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">var</span> delegate =  <span class="type">DemoViewController3Delegate</span>()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">DemoViewController3</span>:<span class="title">URLSessionDelegate</span>, <span class="title">URLSessionDataDelegate</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">urlSession</span><span class="params">(<span class="number">_</span> session: URLSession, dataTask: URLSessionDataTask, didReceive data: Data)</span></span> &#123;</span><br><span class="line">        <span class="keyword">let</span> responseText = <span class="type">String</span>(data: data, encoding: <span class="type">String</span>.<span class="type">Encoding</span>.utf8)</span><br><span class="line">        <span class="built_in">debugPrint</span>(responseText ?? <span class="string">"no text"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">func</span> <span class="title">urlSession</span><span class="params">(<span class="number">_</span> session: URLSession, dataTask: URLSessionDataTask, willCacheResponse proposedResponse: CachedURLResponse, completionHandler: @escaping <span class="params">(CachedURLResponse?)</span></span></span> -&gt; <span class="type">Swift</span>.<span class="type">Void</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">let</span> httpResponse = proposedResponse.response <span class="keyword">as</span>? <span class="type">HTTPURLResponse</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> httpResponse.allHeaderFields[<span class="string">"Cache-Control"</span>] == <span class="literal">nil</span> &#123;</span><br><span class="line">                </span><br><span class="line">                <span class="keyword">let</span> newHeaders = (httpResponse.allHeaderFields <span class="keyword">as</span> <span class="type">NSDictionary</span>).mutableCopy() <span class="keyword">as</span>? <span class="type">NSDictionary</span></span><br><span class="line">                newHeaders?.setValue(<span class="string">"max-age=60"</span>, forKey: <span class="string">"Cache-Control"</span>)</span><br><span class="line">                <span class="keyword">let</span> newResponse = <span class="type">HTTPURLResponse</span>(url: httpResponse.url!, statusCode: httpResponse.statusCode, httpVersion: <span class="string">"HTTP/1.1"</span>, headerFields: newHeaders <span class="keyword">as</span>? [<span class="type">String</span> : <span class="type">String</span>])</span><br><span class="line">                </span><br><span class="line">                <span class="keyword">let</span> newCacheResponse = <span class="type">CachedURLResponse</span>(response: newResponse!, data: proposedResponse.data)</span><br><span class="line">                completionHandler(newCacheResponse)</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        completionHandler(proposedResponse)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// for requestWithoutServerCache2</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DemoViewController3Delegate</span>:<span class="title">NSObject</span>,<span class="title">URLSessionDelegate</span>, <span class="title">URLSessionDataDelegate</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">urlSession</span><span class="params">(<span class="number">_</span> session: URLSession, dataTask: URLSessionDataTask, didReceive data: Data)</span></span> &#123;</span><br><span class="line">        <span class="keyword">let</span> responseText = <span class="type">String</span>(data: data, encoding: <span class="type">String</span>.<span class="type">Encoding</span>.utf8)</span><br><span class="line">        <span class="built_in">debugPrint</span>(responseText ?? <span class="string">"no text"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">func</span> <span class="title">urlSession</span><span class="params">(<span class="number">_</span> session: URLSession, dataTask: URLSessionDataTask, willCacheResponse proposedResponse: CachedURLResponse, completionHandler: @escaping <span class="params">(CachedURLResponse?)</span></span></span> -&gt; <span class="type">Swift</span>.<span class="type">Void</span>) &#123;</span><br><span class="line">        completionHandler(proposedResponse)</span><br><span class="line">        <span class="built_in">debugPrint</span>(proposedResponse)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">`</span><br></pre></td></tr></table></figure>
<h1 id="缓存设计"><a href="#缓存设计" class="headerlink" title="缓存设计"></a>缓存设计</h1><p>从前面对于<strong>URL Loading System</strong>的分析可以看出利用NSURLProtocol或者NSURLCache都可以做客户端缓存，但是NSURLProtocol更多的用于拦截处理，而且如果使用它来做缓存的话需要自己发起请求。而选择URLSession配合NSURLCache的话，则对于接口调用方有更多灵活的控制，而且默认情况下NSURLCache就有缓存，我们只要操作缓存响应的Cache headers即可，因此后者作为我们优先考虑的设计方案。鉴于本文代码使用Swift编写，因此结合目前Swift中流行的网络库Alamofire实现一种相对简单的缓存方案。</p>
<p>根据前面的思路，最早还是想从URLSessionDataDelegate的缓存设置方法入手，而且Alamofire确实对于每个URLSessionDataTask都留有缓存代理方法的回调入口，但查看源码发现这个入口<strong>dataTaskWillCacheResponse</strong>并未对外开发，而如果直接在SessionDelegate的回调入口<strong>dataTaskWillCacheResponseWithCompletion</strong>上进行回调又无法控制每个请求的缓存情况（NSURLSession是多个请求共用的）。当然如果沿着这个思路可以再扩展一个DataTaskDelegate对象以暴漏缓存入口，但是这么一来必须实现URLSessionDataDelegate,而且要想办法Swizzle NSURLSession的缓存代理(或者继承SessionDelegate切换代理),在代理中根据不同的NSURLDataTask进行缓存处理，整个过程对于调用方并不是太友好。</p>
<p>另一个思路就是等Response请求结束后获取缓存的响应CachedURLResponse并且修改（事实上只要是同一个NSURLRequest存储进去默认会更新原有缓存），而且NSURLCache本身就是有内存缓存的，过程并不会太耗时。当然这个方案最重要的是得保证响应完成，所以这里通过Alamofire链式调用使用<strong>response(queue: queue, responseSerializer: responseSerializer, completionHandler: completionHandler</strong>重新请求以保证及时掌握回调时机。主要的代码片段如下：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">func</span> <span class="title">cache</span><span class="params">(maxAge:Int,isPrivate:Bool = <span class="literal">false</span>,ignoreServer:Bool = <span class="literal">true</span>)</span></span></span><br><span class="line">    -&gt; <span class="type">Self</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">var</span> useServerButRefresh = <span class="literal">false</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">let</span> newRequest = <span class="keyword">self</span>.request &#123;</span><br><span class="line">        <span class="keyword">if</span> !ignoreServer &#123;</span><br><span class="line">            <span class="keyword">if</span> newRequest.allHTTPHeaderFields?[<span class="type">AlamofireURLCache</span>.refreshCacheKey] == <span class="type">AlamofireURLCache</span>.<span class="type">RefreshCacheValue</span>.refreshCache.rawValue &#123;</span><br><span class="line">                useServerButRefresh = <span class="literal">true</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> newRequest.allHTTPHeaderFields?[<span class="type">AlamofireURLCache</span>.refreshCacheKey] != <span class="type">AlamofireURLCache</span>.<span class="type">RefreshCacheValue</span>.refreshCache.rawValue &#123;</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">let</span> urlCache = <span class="keyword">self</span>.session.configuration.urlCache &#123;</span><br><span class="line">                <span class="keyword">if</span> <span class="keyword">let</span> value = (urlCache.cachedResponse(<span class="keyword">for</span>: newRequest)?.response <span class="keyword">as</span>? <span class="type">HTTPURLResponse</span>)?.allHeaderFields[<span class="type">AlamofireURLCache</span>.refreshCacheKey] <span class="keyword">as</span>? <span class="type">String</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> value == <span class="type">AlamofireURLCache</span>.<span class="type">RefreshCacheValue</span>.useCache.rawValue &#123;</span><br><span class="line">                        <span class="keyword">return</span> <span class="keyword">self</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> response &#123; [<span class="keyword">unowned</span> <span class="keyword">self</span>](defaultResponse) <span class="keyword">in</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> defaultResponse.request?.httpMethod != <span class="string">"GET"</span> &#123;</span><br><span class="line">            <span class="built_in">debugPrint</span>(<span class="string">"Non-GET requests do not support caching!"</span>)</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> defaultResponse.error != <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="built_in">debugPrint</span>(defaultResponse.error!.localizedDescription)</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">let</span> httpResponse = defaultResponse.response &#123;</span><br><span class="line">            <span class="keyword">guard</span> <span class="keyword">let</span> newRequest = defaultResponse.request <span class="keyword">else</span> &#123; <span class="keyword">return</span> &#125;</span><br><span class="line">            <span class="keyword">guard</span> <span class="keyword">let</span> newData = defaultResponse.data <span class="keyword">else</span> &#123; <span class="keyword">return</span> &#125;</span><br><span class="line">            <span class="keyword">guard</span> <span class="keyword">let</span> newURL = httpResponse.url <span class="keyword">else</span> &#123; <span class="keyword">return</span> &#125;</span><br><span class="line">            <span class="keyword">guard</span> <span class="keyword">let</span> urlCache = <span class="keyword">self</span>.session.configuration.urlCache <span class="keyword">else</span> &#123; <span class="keyword">return</span> &#125;</span><br><span class="line">            <span class="keyword">guard</span> <span class="keyword">let</span> newHeaders = (httpResponse.allHeaderFields <span class="keyword">as</span> <span class="type">NSDictionary</span>).mutableCopy() <span class="keyword">as</span>? <span class="type">NSMutableDictionary</span> <span class="keyword">else</span> &#123; <span class="keyword">return</span> &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> <span class="type">AlamofireURLCache</span>.isCanUseCacheControl &#123;</span><br><span class="line">                <span class="keyword">if</span> httpResponse.allHeaderFields[<span class="string">"Cache-Control"</span>] == <span class="literal">nil</span> || httpResponse.allHeaderFields.keys.<span class="built_in">contains</span>(<span class="string">"no-cache"</span>) || httpResponse.allHeaderFields.keys.<span class="built_in">contains</span>(<span class="string">"no-store"</span>) || ignoreServer || useServerButRefresh &#123;</span><br><span class="line">                    <span class="type">DataRequest</span>.addCacheControlHeaderField(headers: newHeaders, maxAge: maxAge, isPrivate: isPrivate)</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">return</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> httpResponse.allHeaderFields[<span class="string">"Expires"</span>] == <span class="literal">nil</span> || ignoreServer || useServerButRefresh &#123;</span><br><span class="line">                    <span class="type">DataRequest</span>.addExpiresHeaderField(headers: newHeaders, maxAge: maxAge)</span><br><span class="line">                    <span class="keyword">if</span> ignoreServer &amp;&amp; httpResponse.allHeaderFields[<span class="string">"Pragma"</span>] != <span class="literal">nil</span> &#123;</span><br><span class="line">                        newHeaders[<span class="string">"Pragma"</span>] = <span class="string">"cache"</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">return</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            newHeaders[<span class="type">AlamofireURLCache</span>.refreshCacheKey] = <span class="type">AlamofireURLCache</span>.<span class="type">RefreshCacheValue</span>.useCache.rawValue</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">let</span> newResponse = <span class="type">HTTPURLResponse</span>(url: newURL, statusCode: httpResponse.statusCode, httpVersion: <span class="type">AlamofireURLCache</span>.<span class="type">HTTPVersion</span>, headerFields: newHeaders <span class="keyword">as</span>? [<span class="type">String</span> : <span class="type">String</span>]) &#123;</span><br><span class="line">                </span><br><span class="line">                <span class="keyword">let</span> newCacheResponse = <span class="type">CachedURLResponse</span>(response: newResponse, data: newData, userInfo: [<span class="string">"framework"</span>:<span class="type">AlamofireURLCache</span>.frameworkName], storagePolicy: <span class="type">URLCache</span>.<span class="type">StoragePolicy</span>.allowed)</span><br><span class="line">                </span><br><span class="line">                urlCache.storeCachedResponse(newCacheResponse, <span class="keyword">for</span>: newRequest)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>要完成整个缓存处理自然还包括缓存刷新、缓存清理等操作，关于缓存清理本身NSURLCache是提供了<em>remove</em>方法的，不过缓存清理并不及时，调用并不会立即生效，具体参见<a href="https://stackoverflow.com/questions/26260401/nsurlcache-does-not-clear-stored-responses-in-ios8" target="_blank" rel="external">NSURLCache does not clear stored responses in iOS8</a>。因此，这里借助了上面提到的<strong>Cache-Control</strong>进行缓存过期控制，一方面可以快速清理缓存，另一方面缓存控制可以更加精确。</p>
<h2 id="AlamofireURLCache"><a href="#AlamofireURLCache" class="headerlink" title="AlamofireURLCache"></a>AlamofireURLCache</h2><p><img src="/media/AlamofireURLCache_Logo.png" alt="AlamofireURLCache"></p>
<p>为了更好的配合Alamofire使用，此代码以<a href="https://github.com/kenshincui/AlamofireURLCache" target="_blank" rel="external">AlamofireURLCache</a>类库形式在github开源，所有接口API尽量和原有接口保持一致，便于对Alamofire二次封装。此外还提供了手动清理缓存、出错之后自动清理缓存、覆盖服务器端缓存配置等方便的功能，可以满足多数情况下缓存需求细节。</p>
<p>AlamofireURLCache在request方法添加了<em>refreshCache</em>参数用于缓存刷新，设为false或者不提供此参数则不会刷新缓存，只有等到上次缓存数据过了有效期才会再次发起请求。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Alamofire</span>.request(<span class="string">"https://myapi.applinzi.com/url-cache/no-cache.php"</span>,refreshCache:<span class="literal">false</span>).responseJSON(completionHandler: &#123; response <span class="keyword">in</span></span><br><span class="line">    <span class="keyword">if</span> response.value != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">self</span>.textView.text = (response.value <span class="keyword">as</span>! [<span class="type">String</span>:<span class="type">Any</span>]).debugDescription</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">self</span>.textView.text = <span class="string">"Error!"</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;).cache(maxAge: <span class="number">10</span>)</span><br></pre></td></tr></table></figure>
<p>服务器端缓存headers设置并不都是最优选择，某些情况下客户端必须自行控制缓存策略，此时可以使用AlamofireURLCache的<em>ignoreServer</em>参数忽略服务器端配置，通过<em>maxAge</em>参数自行控制缓存时长。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Alamofire</span>.request(<span class="string">"https://myapi.applinzi.com/url-cache/default-cache.php"</span>,refreshCache:<span class="literal">false</span>).responseJSON(completionHandler: &#123; response <span class="keyword">in</span></span><br><span class="line">    <span class="keyword">if</span> response.value != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">self</span>.textView.text = (response.value <span class="keyword">as</span>! [<span class="type">String</span>:<span class="type">Any</span>]).debugDescription</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">self</span>.textView.text = <span class="string">"Error!"</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;).cache(maxAge: <span class="number">10</span>,isPrivate: <span class="literal">false</span>,ignoreServer: <span class="literal">true</span>)</span><br></pre></td></tr></table></figure>
<p>另外，有些情况下未必需要刷新缓存而是要清空缓存保证下次访问时再使用最新数据，此时就需要使用AlamofireURLCache提供的缓存清理API来完成。需要特别说明的是，对于请求出错、序列化出错等情况如果调用了<em>cache(maxAge)</em>方法进行缓存后，那么下次请求会使用错误的缓存数据，需要开发人员根据返回情况自行调用API清理缓存。但更好的选择是使用AlamofireURLCache提供的<em>autoClearCache</em>参数来自动处理此种情况，所以任何时候都推荐将<em>autoClearCache</em>参数设为true以保证不会缓存出错数据。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Alamofire</span>.clearCache(dataRequest: dataRequest) <span class="comment">// clear cache by DataRequest</span></span><br><span class="line"><span class="type">Alamofire</span>.clearCache(request: urlRequest) <span class="comment">// clear cache by URLRequest</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ignore data cache when request error</span></span><br><span class="line"><span class="type">Alamofire</span>.request(<span class="string">"https://myapi.applinzi.com/url-cache/no-cache.php"</span>,refreshCache:<span class="literal">false</span>).responseJSON(completionHandler: &#123; response <span class="keyword">in</span></span><br><span class="line">    <span class="keyword">if</span> response.value != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">self</span>.textView.text = (response.value <span class="keyword">as</span>! [<span class="type">String</span>:<span class="type">Any</span>]).debugDescription</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">self</span>.textView.text = <span class="string">"Error!"</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;,autoClearCache:<span class="literal">true</span>).cache(maxAge: <span class="number">10</span>)</span><br></pre></td></tr></table></figure>
<p>如果阅读本文让你有所收获，欢迎推荐点赞，最后再次附上代码下载！</p>
<p><a href="https://github.com/kenshincui/AlamofireURLCache#cache-and-refresh" target="_blank" rel="external">代码下载</a></p>

  </section>

</article>

<section class="read-more">
           
    
               
            <div class="read-more-item">
                <span class="read-more-item-dim">最近的文章</span>
                <h2 class="post-list__post-title post-title"><a href="/2020/01/13/iOS滤镜系列-滤镜开发概览/" title="iOS滤镜系列-滤镜开发概览">iOS滤镜系列-滤镜开发概览</a></h2>
                <p class="excerpt">
                
                
概述滤镜最早的出现应该是应用在相机镜头前实现自然光过滤和调色的镜片，然而在软件开发中更多的指的是软件滤镜，是对镜头滤镜的模拟实现。当然这种方式更加方便快捷，缺点自然就是无法还原拍摄时的真实场景，例如无法实现偏光镜和紫外线滤色镜的效果。今天简单介绍一下iOS滤镜开发中的正确姿势，让刚刚接触滤镜开发的
                &hellip;
                </p>
                <div class="post-list__meta"><time datetime="2020-01-13T07:53:20.000Z" class="post-list__meta--date date">2020-01-13</time> &#8226; <span class="post-list__meta--tags tags">于&nbsp;
  <a class="tag-link" href="/tags/OpenGL-GPUImage-OpenCV-Core-Image-Metal/">OpenGL , GPUImage , OpenCV , Core Image , Metal</a>
</span><a class="btn-border-small" href="/2020/01/13/iOS滤镜系列-滤镜开发概览/">继续阅读</a></div>
                           
            </div>
        
        
               
            <div class="read-more-item">
                <span class="read-more-item-dim">更早的文章</span>
                <h2 class="post-list__post-title post-title"><a href="/2017/05/08/iOS刨根问底-深入理解RunLoop/" title="iOS刨根问底-深入理解RunLoop">iOS刨根问底-深入理解RunLoop</a></h2>
                <p class="excerpt">
                
                概述RunLoop作为iOS中一个基础组件和线程有着千丝万缕的关系，同时也是很多常见技术的幕后功臣。尽管在平时多数开发者很少直接使用RunLoop，但是理解RunLoop可以帮助开发者更好的利用多线程编程模型，同时也可以帮助开发者解答日常开发中的一些疑惑。本文将从RunLoop源码着手，结合RunL
                &hellip;
                </p>
                <div class="post-list__meta"><time datetime="2017-05-08T03:05:23.000Z" class="post-list__meta--date date">2017-05-08</time> &#8226; <span class="post-list__meta--tags tags">于&nbsp;
  <a class="tag-link" href="/tags/RunLoop/">RunLoop</a>
</span><a class="btn-border-small" href="/2017/05/08/iOS刨根问底-深入理解RunLoop/">继续阅读</a></div>
                       
            </div>
        
     
   
   
  
</section>

  
<section class="post-comments">
  <div id="disqus_thread"></div>
  <script type="text/javascript">
      var disqus_shortname = 'kenshincui'; 
      
  var disqus_identifier = '/2017/06/05/iOS架构设计-URL缓存/';
  var disqus_title = 'iOS架构设计-URL缓存';
  var disqus_url = 'http://yoursite.com/2017/06/05/iOS架构设计-URL缓存/';
  

      /* * * DON'T EDIT BELOW THIS LINE * * */
      (function() {
          var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
          //dsq.src = 'https://' + disqus_shortname + '.disqus.com/embed.js';
          dsq.src = 'https://a.disquscdn.com/embed.js';
          (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
      })();
  </script>
  <noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
  <a href="https://disqus.com" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a>
</section>


            <footer class="footer">
    <span class="footer__copyright">
        本站点采用 <a href="http://creativecommons.org/licenses/by-nc-sa/4.0/">知识共享署名-非商业性使用-相同方式共享 4.0 国际许可协议</a>
    </span>
    <span class="footer__copyright">
        基于 <a href="http://hexo.io">Hexo</a> 搭建，感谢 <a href="https://pages.github.com/">GitHub Pages</a> 提供免费的托管服务
    </span>
    <span class="footer__copyright">
        &copy; 2020 - 本站使用 <a href="https://github.com/monniya/hexo-theme-new-vno ">new-vno</a> 主题,
        由<a href="https://monniya.com ">@Monniya</a> 修改自 <a href="https://github.com/lenbo-ma/hexo-theme-vno" target="_blank">Vno</a>, 原创出自<a href="http://github.com/onevcat/vno" target="_blank">onevcat</a>
    </span>
    
</footer>


        </div>
    </div>

     
    


    <script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    
    
</body>
</html>
