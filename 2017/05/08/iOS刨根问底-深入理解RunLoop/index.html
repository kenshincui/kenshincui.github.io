<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8"/>
    <meta http-equiv="X-UA-Compatible" content="IE=edge"/>
    
    <title>iOS刨根问底-深入理解RunLoop | Kenshin Cui&#39;s Blog</title>
    <meta name="renderer" content="webkit">
    <meta name="HandheldFriendly" content="True">
    <meta name="MobileOptimized" content="320">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

    <meta name="description" content="iOS Developer">

    <meta name="twitter:card" content="summary">
    <meta name="twitter:title" content="iOS刨根问底-深入理解RunLoop | Kenshin Cui&#39;s Blog">
    <meta name="twitter:description" content="iOS Developer">

    <meta property="og:type" content="article">
    <meta property="og:title" content="iOS刨根问底-深入理解RunLoop | Kenshin Cui&#39;s Blog">
    <meta property="og:description" content="iOS Developer">

    
    <meta name="author" content="Kenshin Cui">
    
    <link rel="stylesheet" href="/css/vno.css">
    <link rel="stylesheet" href="//netdna.bootstrapcdn.com/font-awesome/4.1.0/css/font-awesome.min.css">

    
    <link rel="icon" href="/favicon.ico">
    

    <meta name="generator" content="hexo"/>
    

    <link rel="canonical" href="http://yoursite.com/2017/05/08/iOS刨根问底-深入理解RunLoop/"/>

                 
</head>

<body class="home-template no-js">
    <script src="//cdn.bootcss.com/jquery/2.1.4/jquery.min.js"></script>
    <script src="/js/main.js"></script>
    <span class="mobile btn-mobile-menu">
        <i class="fa fa-list btn-mobile-menu__icon"></i>
        <i class="fa fa-angle-up btn-mobile-close__icon hidden"></i>
    </span>

    
<header class="panel-cover panel-cover--collapsed" style="background-image: url(/images/background-cover.jpg)">
  <div class="panel-main">
    <div class="panel-main__inner panel-inverted">
    <div class="panel-main__content">

        <a href="/" title="前往 Kenshin Cui&#39;s Blog 的主页"><img src="/images/avatar.jpg" width="80" alt="Kenshin Cui&#39;s Blog logo" class="panel-cover__logo logo" /></a>
        <h1 class="panel-cover__title panel-title"><a href="/" title="link to homepage for Kenshin Cui&#39;s Blog">Kenshin Cui&#39;s Blog</a></h1>
        
        <span class="panel-cover__subtitle panel-subtitle">即便是别人看不到的地方, 对其工艺也必须尽心尽力。</span>
        
        <hr class="panel-cover__divider" />
        <p class="panel-cover__description">iOS Developer</p>
        <hr class="panel-cover__divider panel-cover__divider--secondary" />

        <div class="navigation-wrapper">
          <div>
          <nav class="cover-navigation cover-navigation--primary">
            <ul class="navigation">
              <li class="navigation__item"><a href="/#blog" title="访问博客" class="blog-button">博客</a></li>
            
              <li class="navigation__item"><a href="/archive">归档</a></li>
            
              <li class="navigation__item"><a href="/about">关于</a></li>
            
            </ul>
          </nav>
          </div>
          <div>
          <nav class="cover-navigation navigation--social">
  <ul class="navigation">

  <!-- Weibo-->
  

  <!-- Github -->
  
  <li class="navigation__item">
    <a href="https://github.com/kenshincui" title="查看我的GitHub主页" target="_blank">
      <i class='social fa fa-github'></i>
      <span class="label">Github</span>
    </a>
  </li>


<!-- Stack Overflow -->
        

  <!-- Google Plus -->
  

<!-- Facebook -->

  
<!-- Twitter -->

  



  </ul>
</nav>

          </div>
        </div>

      </div>

    </div>

    <div class="panel-cover--overlay cover-green"></div>
  </div> 
</header>

    <div class="content-wrapper">
        <div class="content-wrapper__inner">
            <article class="post-container post-container--single">

  <header class="post-header">
    <div class="post-meta">
      <time datetime="2017-05-08T03:05:23.000Z" class="post-list__meta--date date">2017-05-08</time> &#8226; <span class="post-meta__tags tags">于&nbsp;
  <a class="tag-link" href="/tags/RunLoop/">RunLoop</a>
 </span>
      <span class="page-pv">
      &nbsp;阅读&nbsp;<span id="busuanzi_value_page_pv"><i class="fa fa-spinner fa-spin"></i></span>
      </span> 
   
    </div>
    <h1 class="post-title">iOS刨根问底-深入理解RunLoop</h1>
  </header>

  <section class="post">
    <h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>RunLoop作为iOS中一个基础组件和线程有着千丝万缕的关系，同时也是很多常见技术的幕后功臣。尽管在平时多数开发者很少直接使用RunLoop，但是理解RunLoop可以帮助开发者更好的利用多线程编程模型，同时也可以帮助开发者解答日常开发中的一些疑惑。本文将从RunLoop源码着手，结合RunLoop的实际应用来逐步解开它的神秘面纱。</p>
<h1 id="开源的RunloopRef"><a href="#开源的RunloopRef" class="headerlink" title="开源的RunloopRef"></a>开源的RunloopRef</h1><p>通常所说的RunLoop指的是NSRunloop或者CFRunloopRef，CFRunloopRef是纯C的函数，而NSRunloop仅仅是CFRunloopRef的OC封装，并未提供额外的其他功能，因此下面主要分析CFRunloopRef，苹果已经开源了CoreFoundation源代码，因此很容易找到CFRunloop<a href="http://opensource.apple.com/source/CF/CF-855.17/CFRunLoop.c" target="_blank" rel="external">源代码</a>。<br>从代码可以看出CFRunloopRef其实就是<strong>__CFRunloop</strong>这个结构体指针（按照OC的思路我们可以将RunLoop看成一个对象），这个对象的运行才是我们通常意义上说的运行循环，核心方法是<strong>__CFRunloopRun()</strong>，为了便于阅读就不再直接贴源代码，放一段伪代码方便大家阅读：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line">int32_t __<span class="built_in">CFRunLoopRun</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 通知即将进入runloop</span></span><br><span class="line">    __<span class="built_in">CFRunLoopDoObservers</span>(K<span class="built_in">CFRunLoopEntry</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">do</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 通知将要处理timer和source</span></span><br><span class="line">        __<span class="built_in">CFRunLoopDoObservers</span>(k<span class="built_in">CFRunLoopBeforeTimers</span>);</span><br><span class="line">        __<span class="built_in">CFRunLoopDoObservers</span>(k<span class="built_in">CFRunLoopBeforeSources</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 处理非延迟的主线程调用</span></span><br><span class="line">        __<span class="built_in">CFRunLoopDoBlocks</span>();</span><br><span class="line">        <span class="comment">// 处理Source0事件</span></span><br><span class="line">        __<span class="built_in">CFRunLoopDoSource0</span>();</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (sourceHandledThisLoop) &#123;</span><br><span class="line">            __<span class="built_in">CFRunLoopDoBlocks</span>();</span><br><span class="line">	     &#125;</span><br><span class="line">        <span class="comment">/// 如果有 Source1 (基于port) 处于 ready 状态，直接处理这个 Source1 然后跳转去处理消息。</span></span><br><span class="line">        <span class="keyword">if</span> (__Source0DidDispatchPortLastTime) &#123;</span><br><span class="line">            Boolean hasMsg = __<span class="built_in">CFRunLoopServiceMachPort</span>();</span><br><span class="line">            <span class="keyword">if</span> (hasMsg) <span class="keyword">goto</span> handle_msg;</span><br><span class="line">        &#125;</span><br><span class="line">            </span><br><span class="line">        <span class="comment">/// 通知 Observers: RunLoop 的线程即将进入休眠(sleep)。</span></span><br><span class="line">        <span class="keyword">if</span> (!sourceHandledThisLoop) &#123;</span><br><span class="line">            __<span class="built_in">CFRunLoopDoObservers</span>(runloop, currentMode, k<span class="built_in">CFRunLoopBeforeWaiting</span>);</span><br><span class="line">        &#125;</span><br><span class="line">            </span><br><span class="line">        <span class="comment">// GCD dispatch main queue</span></span><br><span class="line">        CheckIfExistMessagesInMainDispatchQueue();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 即将进入休眠</span></span><br><span class="line">        __<span class="built_in">CFRunLoopDoObservers</span>(k<span class="built_in">CFRunLoopBeforeWaiting</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 等待内核mach_msg事件</span></span><br><span class="line">        mach_port_t wakeUpPort = SleepAndWaitForWakingUpPorts();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 等待。。。</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 从等待中醒来</span></span><br><span class="line">        __<span class="built_in">CFRunLoopDoObservers</span>(k<span class="built_in">CFRunLoopAfterWaiting</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 处理因timer的唤醒</span></span><br><span class="line">        <span class="keyword">if</span> (wakeUpPort == timerPort)</span><br><span class="line">            __<span class="built_in">CFRunLoopDoTimers</span>();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 处理异步方法唤醒,如dispatch_async</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (wakeUpPort == mainDispatchQueuePort)</span><br><span class="line">            __<span class="built_in">CFRUNLOOP_IS_SERVICING_THE_MAIN_DISPATCH_QUEUE__</span>()</span><br><span class="line">            </span><br><span class="line">        <span class="comment">// 处理Source1</span></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            __<span class="built_in">CFRunLoopDoSource1</span>();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 再次确保是否有同步的方法需要调用</span></span><br><span class="line">        __<span class="built_in">CFRunLoopDoBlocks</span>();</span><br><span class="line">        </span><br><span class="line">    &#125; <span class="keyword">while</span> (!stop &amp;&amp; !timeout);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 通知即将退出runloop</span></span><br><span class="line">    __<span class="built_in">CFRunLoopDoObservers</span>(<span class="built_in">CFRunLoopExit</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>源代码尽管不算太长，但是如果不太熟悉的话面对这么一堆不知道做什么的函数调用还是会给人一种神秘感。但是现在可以不用逐行阅读，后面慢慢解开这层神秘面纱。现在只要了解上面的伪代码知道核心的方法<strong>__CFRunLoopRun</strong>内部其实是一个<em>do while</em>循环，这也正是Runloop运行的本质。执行了这个函数以后就一直处于“等待-处理”的循环之中，直到循环结束。只是不同于我们自己写的循环它在休眠时几乎不会占用系统资源，当然这是由于系统内核负责实现的，也是Runloop精华所在。</p>
<blockquote>
<p>随着Swift的开源苹果也维护了一个Swift版本的跨平台<a href="https://github.com/apple/swift-corelibs-foundation/" target="_blank" rel="external">CoreFoundation</a>版本，除了mac平台它还是适配了Linux和Windows平台。但是鉴于目前很多关于Runloop的讨论都是以OC版展开的，所以这里也主要分析OC版本。</p>
</blockquote>
<p>下图描述了Runloop运行流程（基本描述了上面Runloop的核心流程，当然可以查看官方<a href="https://developer.apple.com/library/content/documentation/Cocoa/Conceptual/Multithreading/RunLoopManagement/RunLoopManagement.html#//apple_ref/doc/uid/10000057i-CH16-SW23" target="_blank" rel="external">The Run Loop Sequence of Events</a>描述）：</p>
<p><img src="/media/RunLoopFlow.png" alt="RunLoop"></p>
<p>整个流程并不复杂（需要注意的就是<em>黄色</em>区域的消息处理中并不包含source0，因为它在循环开始之初就会处理），整个流程其实就是一种<a href="https://en.wikipedia.org/wiki/Event_loop" target="_blank" rel="external">Event Loop</a>的实现，其他平台均有类似的实现，只是这里叫做Runloop。但是既然RunLoop是一个消息循环，谁来管理和运行Runloop？那么它接收什么类型的消息？休眠过程是怎么样的？如何保证休眠时不占用系统资源？如何处理这些消息以及何时退出循环？还有一系列问题需要解开。</p>
<blockquote>
<p>注意的是尽管CFRunLoopPerformBlock在上图中作为唤醒机制有所体现，但事实上执行CFRunLoopPerformBlock只是入队，下次RunLoop运行才会执行，而如果需要立即执行则必须调用CFRunLoopWakeUp。</p>
</blockquote>
<h2 id="Runloop-Mode"><a href="#Runloop-Mode" class="headerlink" title="Runloop Mode"></a>Runloop Mode</h2><p>从源码很容易看出，Runloop总是运行在某种特定的<strong>CFRunLoopModeRef</strong>下（每次运行<strong>__CFRunLoopRun()</strong>函数时必须指定Mode）。而通过<strong>CFRunloopRef</strong>对应结构体的定义可以很容易知道每种Runloop都可以包含若干个Mode，每个Mode又包含Source/Timer/Observer。每次调用Runloop的主函数<strong>__CFRunLoopRun()</strong>时必须指定一种Mode，这个Mode称为<strong> _currentMode</strong>，当切换Mode时必须退出当前Mode，然后重新进入Runloop以保证不同Mode的Source/Timer/Observer互不影响。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> __CFRunLoop &#123;</span><br><span class="line">    CFRuntimeBase _base;</span><br><span class="line">    <span class="keyword">pthread_mutex_t</span> _lock;			<span class="comment">/* locked for accessing mode list */</span></span><br><span class="line">    __CFPort _wakeUpPort;			<span class="comment">// used for CFRunLoopWakeUp </span></span><br><span class="line">    Boolean _unused;</span><br><span class="line">    <span class="keyword">volatile</span> _per_run_data *_perRunData;              <span class="comment">// reset for runs of the run loop</span></span><br><span class="line">    <span class="keyword">pthread_t</span> _pthread;</span><br><span class="line">    <span class="keyword">uint32_t</span> _winthread;</span><br><span class="line">    CFMutableSetRef _commonModes;</span><br><span class="line">    CFMutableSetRef _commonModeItems;</span><br><span class="line">    CFRunLoopModeRef _currentMode;</span><br><span class="line">    CFMutableSetRef _modes;</span><br><span class="line">    <span class="keyword">struct</span> _block_item *_blocks_head;</span><br><span class="line">    <span class="keyword">struct</span> _block_item *_blocks_tail;</span><br><span class="line">    CFAbsoluteTime _runTime;</span><br><span class="line">    CFAbsoluteTime _sleepTime;</span><br><span class="line">    CFTypeRef _counterpart;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> __CFRunLoopMode &#123;</span><br><span class="line">    CFRuntimeBase _base;</span><br><span class="line">    <span class="keyword">pthread_mutex_t</span> _lock;	<span class="comment">/* must have the run loop locked before locking this */</span></span><br><span class="line">    CFStringRef _name;</span><br><span class="line">    Boolean _stopped;</span><br><span class="line">    <span class="keyword">char</span> _padding[<span class="number">3</span>];</span><br><span class="line">    CFMutableSetRef _sources0;</span><br><span class="line">    CFMutableSetRef _sources1;</span><br><span class="line">    CFMutableArrayRef _observers;</span><br><span class="line">    CFMutableArrayRef _timers;</span><br><span class="line">    CFMutableDictionaryRef _portToV1SourceMap;</span><br><span class="line">    __CFPortSet _portSet;</span><br><span class="line">    CFIndex _observerMask;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> USE_DISPATCH_SOURCE_FOR_TIMERS</span></span><br><span class="line">    <span class="keyword">dispatch_source_t</span> _timerSource;</span><br><span class="line">    <span class="keyword">dispatch_queue_t</span> _queue;</span><br><span class="line">    Boolean _timerFired; <span class="comment">// set to true by the source when a timer has fired</span></span><br><span class="line">    Boolean _dispatchTimerArmed;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> USE_MK_TIMER_TOO</span></span><br><span class="line">    <span class="keyword">mach_port_t</span> _timerPort;</span><br><span class="line">    Boolean _mkTimerArmed;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> DEPLOYMENT_TARGET_WINDOWS</span></span><br><span class="line">    DWORD _msgQMask;</span><br><span class="line">    <span class="keyword">void</span> (*_msgPump)(<span class="keyword">void</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="keyword">uint64_t</span> _timerSoftDeadline; <span class="comment">/* TSR */</span></span><br><span class="line">    <span class="keyword">uint64_t</span> _timerHardDeadline; <span class="comment">/* TSR */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>系统默认提供的Run Loop Modes有<strong>kCFRunLoopDefaultMode(NSDefaultRunLoopMode)</strong>和<strong>UITrackingRunLoopMode</strong>，需要切换到对应的Mode时只需要传入对应的名称即可。前者是系统默认的Runloop Mode，例如进入iOS程序默认不做任何操作就处于这种Mode中，此时滑动UIScrollView，主线程就切换Runloop到到UITrackingRunLoopMode，不再接受其他事件操作（除非你将其他Source/Timer设置到UITrackingRunLoopMode下）。<br>但是对于开发者而言经常用到的Mode还有一个<strong>kCFRunLoopCommonModes（NSRunLoopCommonModes）</strong>,其实这个并不是某种具体的Mode，而是一种模式组合，在iOS系统中默认包含了<br><strong> NSDefaultRunLoopMode</strong>和<strong> UITrackingRunLoopMode</strong>（注意：并不是说Runloop会运行在<strong>kCFRunLoopCommonModes</strong>这种模式下，而是相当于分别注册了<strong> NSDefaultRunLoopMode</strong>和<strong> UITrackingRunLoopMode</strong>。当然你也可以通过调用<strong>CFRunLoopAddCommonMode()</strong>方法将自定义Mode放到<strong> kCFRunLoopCommonModes</strong>组合）。</p>
<blockquote>
<p>注意：我们常常还会碰到一些系统框架自定义Mode，例如Foundation中NSConnectionReplyMode。还有一些系统私有Mode，例如：GSEventReceiveRunLoopMode接受系统事件，UIInitializationRunLoopMode App启动过程中初始化Mode。更多系统或框架Mode查看<a href="http://iphonedevwiki.net/index.php/CFRunLoop" target="_blank" rel="external">这里</a></p>
</blockquote>
<p>CFRunLoopRef和CFRunloopMode、CFRunLoopSourceRef/CFRunloopTimerRef/CFRunLoopObserverRef关系如下图：</p>
<p><img src="/media/RunloopMode.png" alt="RunLoopMode"></p>
<p>那么CFRunLoopSourceRef、CFRunLoopTimerRef和CFRunLoopObserverRef究竟是什么？它们在Runloop运行流程中起到什么作用呢？</p>
<h2 id="Source"><a href="#Source" class="headerlink" title="Source"></a>Source</h2><p>首先看一下官方Runloop结构图（注意下图的Input Source Port和前面流程图中的Source0并不对应，而是对应Source1。Source1和Timer都属于端口事件源，不同的是所有的Timer都共用一个端口“Mode Timer Port”，而每个Source1都有不同的对应端口）：</p>
<p><img src="/media/runloop_source.JPG" alt="RunLoopSource"></p>
<p>再结合前面RunLoop核心运行流程可以看出Source0(负责App内部事件，由App负责管理触发，例如UITouch事件)和Timer（又叫Timer Source，基于时间的触发器，上层对应NSTimer）是两个不同的Runloop事件源（当然Source0是Input Source中的一类，Input Source还包括Custom Input Source，由其他线程手动发出），RunLoop被这些事件唤醒之后就会处理并调用事件处理方法（CFRunLoopTimerRef的回调指针和CFRunLoopSourceRef均包含对应的回调指针）。<br>但是对于CFRunLoopSourceRef除了Source0之外还有另一个版本就是Source1，Source1除了包含回调指针外包含一个<strong>mach port</strong>，和Source0需要手动触发不同，Source1可以监听系统端口和其他线程相互发送消息，它能够主动唤醒RunLoop(由操作系统内核进行管理，例如CFMessagePort消息)。官方也指出可以自定义Source，因此对于CFRunLoopSourceRef来说它更像一种协议，框架已经默认定义了两种实现，如果有必要开发人员也可以自定义，详细情况可以查看<a href="https://developer.apple.com/library/content/documentation/Cocoa/Conceptual/Multithreading/RunLoopManagement/RunLoopManagement.html" target="_blank" rel="external">官方文档</a>。</p>
<h2 id="Observer"><a href="#Observer" class="headerlink" title="Observer"></a>Observer</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> __CFRunLoopObserver &#123;</span><br><span class="line">    CFRuntimeBase _base;</span><br><span class="line">    <span class="keyword">pthread_mutex_t</span> _lock;</span><br><span class="line">    CFRunLoopRef _runLoop;</span><br><span class="line">    CFIndex _rlCount;</span><br><span class="line">    CFOptionFlags _activities;		<span class="comment">/* immutable */</span></span><br><span class="line">    CFIndex _order;			<span class="comment">/* immutable */</span></span><br><span class="line">    CFRunLoopObserverCallBack _callout;	<span class="comment">/* immutable */</span></span><br><span class="line">    CFRunLoopObserverContext _context;	<span class="comment">/* immutable, except invalidation */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>相对来说CFRunloopObserverRef理解起来并不复杂，它相当于消息循环中的一个监听器，随时通知外部当前RunLoop的运行状态（它包含一个函数指针<em>callout</em>将当前状态及时告诉观察者）。具体的Observer状态如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Run Loop Observer Activities */</span></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">CF_OPTIONS</span><span class="params">(CFOptionFlags, CFRunLoopActivity)</span> </span>&#123;</span><br><span class="line">    kCFRunLoopEntry = (<span class="number">1U</span>L &lt;&lt; <span class="number">0</span>), <span class="comment">// 进入RunLoop </span></span><br><span class="line">    kCFRunLoopBeforeTimers = (<span class="number">1U</span>L &lt;&lt; <span class="number">1</span>), <span class="comment">// 即将开始Timer处理</span></span><br><span class="line">    kCFRunLoopBeforeSources = (<span class="number">1U</span>L &lt;&lt; <span class="number">2</span>), <span class="comment">// 即将开始Source处理</span></span><br><span class="line">    kCFRunLoopBeforeWaiting = (<span class="number">1U</span>L &lt;&lt; <span class="number">5</span>), <span class="comment">// 即将进入休眠</span></span><br><span class="line">    kCFRunLoopAfterWaiting = (<span class="number">1U</span>L &lt;&lt; <span class="number">6</span>), <span class="comment">//从休眠状态唤醒</span></span><br><span class="line">    kCFRunLoopExit = (<span class="number">1U</span>L &lt;&lt; <span class="number">7</span>), <span class="comment">//退出RunLoop</span></span><br><span class="line">    kCFRunLoopAllActivities = <span class="number">0x0FFFFFFF</span>U</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="Call-out"><a href="#Call-out" class="headerlink" title="Call out"></a>Call out</h2><p>在开发过程中几乎所有的操作都是通过Call out进行回调的(无论是Observer的状态通知还是Timer、Source的处理)，而系统在回调时通常使用如下几个函数进行回调(换句话说你的代码其实最终都是通过下面几个函数来负责调用的，即使你自己监听Observer也会先调用下面的函数然后间接通知你，所以在调用堆栈中经常看到这些函数)：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> __CFRUNLOOP_IS_CALLING_OUT_TO_AN_OBSERVER_CALLBACK_FUNCTION__();</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> __CFRUNLOOP_IS_CALLING_OUT_TO_A_BLOCK__();</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> __CFRUNLOOP_IS_SERVICING_THE_MAIN_DISPATCH_QUEUE__();</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> __CFRUNLOOP_IS_CALLING_OUT_TO_A_TIMER_CALLBACK_FUNCTION__();</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> __CFRUNLOOP_IS_CALLING_OUT_TO_A_SOURCE0_PERFORM_FUNCTION__();</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> __CFRUNLOOP_IS_CALLING_OUT_TO_A_SOURCE1_PERFORM_FUNCTION__();</span><br></pre></td></tr></table></figure>
<p>例如在控制器的touchBegin中打入断点查看堆栈（由于UIEvent是Source0，所以可以看到一个Source0的Call out函数<strong><strong>CFRUNLOOP_IS_CALLING_OUT_TO_A_SOURCE0_PERFORM_FUNCTION</strong></strong>调用）：</p>
<p><img src="/edia/RunLoop_Source0_UITouch.png" alt="RunLoop_Source0_UITouchm"></p>
<h2 id="RunLoop休眠"><a href="#RunLoop休眠" class="headerlink" title="RunLoop休眠"></a>RunLoop休眠</h2><p>其实对于Event Loop而言RunLoop最核心的事情就是保证线程在没有消息时休眠以避免占用系统资源，有消息时能够及时唤醒。RunLoop的这个机制完全依靠系统内核来完成，具体来说是苹果操作系统核心组件Darwin中的Mach来完成的（<a href="https://opensource.apple.com" target="_blank" rel="external">Darwin</a>是开源的）。可以从下图最底层Kernel中找到Mach：</p>
<p><img src="/media/osx_architecture-kernels_drivers_2x.png" alt="osx_architecture-kernels_drivers"></p>
<p>Mach是Darwin的核心，可以说是内核的核心，提供了进程间通信（IPC）、处理器调度等基础服务。在Mach中，进程、线程间的通信是以消息的方式来完成的，消息在两个Port之间进行传递（这也正是Source1之所以称之为Port-based Source的原因，因为它就是依靠系统发送消息到指定的Port来触发的）。消息的发送和接收使用<mach message.h="">中的<strong>mach_msg()</strong>函数（事实上苹果提供的Mach API很少，并不鼓励我们直接调用这些API）：</mach></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span><br><span class="line"> *	Routine:	mach_msg</span><br><span class="line"> *	Purpose:</span><br><span class="line"> *		Send and/or receive a message.  If the message operation</span><br><span class="line"> *		is interrupted, and the user did not request an indication</span><br><span class="line"> *		of that fact, then restart the appropriate parts of the</span><br><span class="line"> *		operation silently (trap version does not restart).</span><br><span class="line"> */</span></span><br><span class="line">__WATCHOS_PROHIBITED __<span class="function">TVOS_PROHIBITED</span><br><span class="line"><span class="keyword">extern</span> mach_msg_return_t	<span class="title">mach_msg</span><span class="params">(</span><br><span class="line">					mach_msg_header_t *msg,</span><br><span class="line">					mach_msg_option_t option,</span><br><span class="line">					mach_msg_size_t send_size,</span><br><span class="line">					mach_msg_size_t rcv_size,</span><br><span class="line">					mach_port_name_t rcv_name,</span><br><span class="line">					mach_msg_timeout_t timeout,</span><br><span class="line">					mach_port_name_t notify)</span></span>;</span><br></pre></td></tr></table></figure>
<p>而<strong>mach_msg()</strong>的本质是一个调用<strong>mach_msg_trap()</strong>,这相当于一个系统调用，会触发内核状态切换。当程序静止时，RunLoop停留在<strong>__CFRunLoopServiceMachPort(waitSet, &amp;msg, sizeof(msg_buffer), &amp;livePort, poll ? 0 : TIMEOUT_INFINITY, &amp;voucherState, &amp;voucherCopy)</strong>,而这个函数内部就是调用了<strong>mach_msg</strong>让程序处于休眠状态。</p>
<h2 id="Runloop和线程的关系"><a href="#Runloop和线程的关系" class="headerlink" title="Runloop和线程的关系"></a>Runloop和线程的关系</h2><p>Runloop是基于pthread进行管理的，pthread是基于c的跨平台多线程操作底层API。它是mach thread的上层封装（可以参见<a href="https://developer.apple.com/library/content/documentation/Darwin/Conceptual/KernelProgramming/Mach/Mach.html" target="_blank" rel="external">Kernel Programming Guide</a>），和NSThread一一对应（而NSThread是一套面向对象的API，所以在iOS开发中我们也几乎不用直接使用pthread）。</p>
<p><img src="/media/pthread.gif" alt="pthread"></p>
<p>苹果开发的接口中并没有直接创建Runloop的接口，如果需要使用Runloop通常<strong>CFRunLoopGetMain()</strong>和<strong>CFRunLoopGetCurrent()</strong>两个方法来获取（通过上面的源代码也可以看到，核心逻辑在<em>CFRunLoopGet</em>当中）,通过代码并不难发现其实只有当我们使用线程的方法主动<em>get</em> Runloop时才会在第一次创建该线程的Runloop，同时将它保存在全局的Dictionary中（线程和Runloop二者一一对应），默认情况下线程并不会创建Runloop（主线程的Runloop比较特殊，任何线程创建之前都会保证主线程已经存在Runloop），同时在线程结束的时候也会销毁对应的Runloop。</p>
<p>iOS开发过程中对于开发者而言更多的使用的是NSRunloop,它默认提供了三个常用的run方法：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)run; </span><br><span class="line">- (<span class="built_in">BOOL</span>)runMode:(<span class="built_in">NSRunLoopMode</span>)mode beforeDate:(<span class="built_in">NSDate</span> *)limitDate;</span><br><span class="line">- (<span class="keyword">void</span>)runUntilDate:(<span class="built_in">NSDate</span> *)limitDate;</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>run</strong>方法对应上面CFRunloopRef中的<strong>CFRunLoopRun</strong>并不会退出，除非调用<strong>CFRunLoopStop()</strong>;通常如果想要永远不会退出RunLoop才会使用此方法，否则可以使用runUntilDate。</li>
<li><strong>runMode:beforeDate:</strong>则对应<strong>CFRunLoopRunInMode(mode,limiteDate,true)</strong>方法,只执行一次，执行完就退出；通常用于手动控制RunLoop（例如在while循环中）。</li>
<li><strong>runUntilDate:</strong>方法其实是<strong>CFRunLoopRunInMode(kCFRunLoopDefaultMode,limiteDate,false)</strong>，执行完并不会退出，继续下一次RunLoop直到timeout。</li>
</ul>
<h1 id="RunLoop应用"><a href="#RunLoop应用" class="headerlink" title="RunLoop应用"></a>RunLoop应用</h1><h2 id="NSTimer"><a href="#NSTimer" class="headerlink" title="NSTimer"></a>NSTimer</h2><p>前面一直提到Timer Source作为事件源，事实上它的上层对应就是NSTimer（其实就是CFRunloopTimerRef）这个开发者经常用到的定时器（底层基于使用<strong>mk_timer</strong>实现），甚至很多开发者接触RunLoop还是从NSTimer开始的。其实NSTimer定时器的触发正是基于RunLoop运行的，所以使用NSTimer之前必须注册到RunLoop，但是RunLoop为了节省资源并不会在非常准确的时间点调用定时器，如果一个任务执行时间较长，那么当错过一个时间点后只能等到下一个时间点执行，并不会延后执行（NSTimer提供了一个tolerance属性用于设置宽容度，如果确实想要使用NSTimer并且希望尽可能的准确，则可以设置此属性）。</p>
<p>NSTimer的创建通常有两种方式，尽管都是类方法，一种是timerWithXXX，另一种scheduedTimerWithXXX。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">	+ (<span class="built_in">NSTimer</span> *)timerWithTimeInterval:(<span class="built_in">NSTimeInterval</span>)ti invocation:(<span class="built_in">NSInvocation</span> *)invocation repeats:(<span class="built_in">BOOL</span>)yesOrNo;</span><br><span class="line">	+ (<span class="built_in">NSTimer</span> *)timerWithTimeInterval:(<span class="built_in">NSTimeInterval</span>)ti target:(<span class="keyword">id</span>)aTarget selector:(SEL)aSelector userInfo:(nullable <span class="keyword">id</span>)userInfo repeats:(<span class="built_in">BOOL</span>)yesOrNo</span><br><span class="line">	+ (<span class="built_in">NSTimer</span> *)timerWithTimeInterval:(<span class="built_in">NSTimeInterval</span>)interval repeats:(<span class="built_in">BOOL</span>)repeats block:(<span class="keyword">void</span> (^)(<span class="built_in">NSTimer</span> *timer))block ;</span><br><span class="line">	+ (<span class="built_in">NSTimer</span> *)scheduledTimerWithTimeInterval:(<span class="built_in">NSTimeInterval</span>)ti invocation:(<span class="built_in">NSInvocation</span> *)invocation repeats:(<span class="built_in">BOOL</span>)yesOrNo;</span><br><span class="line">	+ (<span class="built_in">NSTimer</span> *)scheduledTimerWithTimeInterval:(<span class="built_in">NSTimeInterval</span>)interval repeats:(<span class="built_in">BOOL</span>)repeats block:(<span class="keyword">void</span> (^)(<span class="built_in">NSTimer</span> *timer))block ;</span><br><span class="line">	+ (<span class="built_in">NSTimer</span> *)scheduledTimerWithTimeInterval:(<span class="built_in">NSTimeInterval</span>)ti target:(<span class="keyword">id</span>)aTarget selector:(SEL)aSelector userInfo:(nullable <span class="keyword">id</span>)userInfo repeats:(<span class="built_in">BOOL</span>)yesOrNo</span><br><span class="line">```	</span><br><span class="line"></span><br><span class="line">二者最大的区别就是后者除了创建一个定时器外会自动以**<span class="built_in">NSDefaultRunLoopMode</span>**Mode添加到当前线程RunLoop中，不添加到RunLoop中的<span class="built_in">NSTimer</span>是无法正常工作的。例如下面的代码中如果timer2不加入到RunLoop中是无法正常工作的。同时注意如果滚动<span class="built_in">UIScrollView</span>（<span class="built_in">UITableView</span>、<span class="built_in">UICollectionview</span>是类似的）二者是无法正常工作的，但是如果将<span class="built_in">NSDefaultRunLoopMode</span>改为<span class="built_in">NSRunLoopCommonModes</span>则可以正常工作，这也解释了前面介绍的Mode内容。</span><br></pre></td></tr></table></figure>
<pre><code>#import &quot;ViewController1.h&quot;

@interface ViewController1 ()
@property (nonatomic,weak) NSTimer *timer1;
@property (nonatomic,weak) NSTimer *timer2;
@end

@implementation ViewController1

- (void)viewDidLoad {
    [super viewDidLoad];
    self.view.backgroundColor = [UIColor blueColor];
    // timer1创建后会自动以NSDefaultRunLoopMode默认模式添加到当前RunLoop中，所以可以正常工作
    self.timer1 = [NSTimer scheduledTimerWithTimeInterval:1.0 target:self selector:@selector(timeInterval:) userInfo:nil repeats:YES];
    NSTimer *tempTimer = [NSTimer timerWithTimeInterval:1.0 target:self selector:@selector(timeInterval:) userInfo:nil repeats:YES];
    // 如果不把timer2添加到RunLoop中是无法正常工作的(注意如果想要在滚动UIScrollView时timer2可以正常工作可以将NSDefaultRunLoopMode改为NSRunLoopCommonModes)
    [[NSRunLoop currentRunLoop] addTimer:tempTimer forMode:NSDefaultRunLoopMode];
    self.timer2 = tempTimer;

    CGRect rect = [UIScreen mainScreen].bounds;
    UIScrollView *scrollView = [[UIScrollView alloc] initWithFrame:CGRectInset(rect, 0, 200)];
    [self.view addSubview:scrollView];

    UIView *contentView = [[UIView alloc] initWithFrame:CGRectInset(scrollView.bounds, -100, -100)];
    contentView.backgroundColor = [UIColor redColor];
    [scrollView addSubview:contentView];
    scrollView.contentSize = contentView.frame.size;
}

- (void)timeInterval:(NSTimer *)timer {
    if (self.timer1 == timer) {
        NSLog(@&quot;timer1...&quot;);
    } else {
        NSLog(@&quot;timer2...&quot;);
    }
}

- (void)touchesBegan:(NSSet&lt;UITouch *&gt; *)touches withEvent:(UIEvent *)event {
    [self dismissViewControllerAnimated:true completion:nil];
}

- (void)dealloc {
    NSLog(@&quot;ViewController1 dealloc...&quot;);
}
@end
</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">注意上面代码中UIViewController1对timer1和timer2并没有强引用，对于普通的对象而言，执行完viewDidLoad方法之后（准确的说应该是执行完viewDidLoad方法后的的一个RunLoop运行结束）二者应该会被释放，但事实上二者并没有被释放。原因是：为了确保定时器正常运转，当加入到RunLoop以后系统会对NSTimer执行一次retain操作（特别注意：timer2创建时并没直接赋值给timer2，原因是timer2是weak属性，如果直接赋值给timer2会被立即释放，因为timerWithXXX方法创建的NSTimer默认并没有加入RunLoop，只有后面加入RunLoop以后才可以将引用指向timer2）。</span><br><span class="line">但是即使使用了弱引用，上面的代码中ViewController1也无法正常释放，原因是在创建NSTimer2时指定了target为self，这样一来造成了timer1和timer2对ViewController1有一个强引用。解决这个问题的方法通常有两种：一种是将target分离出来独立成一个对象（在这个对象中创建NSTimer并将对象本身作为NSTimer的target），控制器通过这个对象间接使用NSTimer；另一种方式的思路仍然是转移target，只是可以直接增加NSTimer扩展（分类），让NSTimer自身做为target，同时可以将操作selector封装到block中。后者相对优雅，也是目前使用较多的方案（目前有大量类似的封装，例如：[NSTimer+Block](https://github.com/mBrissman/NSTimer-Block)）。显然Apple也认识到了这个问题，如果你可以确保代码只在iOS 10下运行就可以使用iOS 10新增的系统级block方案（上面的代码中已经贴出这种方法）。</span><br><span class="line">当然使用上面第二种方法可以解决控制器无法释放的问题，但是会发现即使控制器被释放了两个定时器仍然正常运行，要解决这个问题就需要调用NSTimer的**invalidate**方法（注意：无论是重复执行的定时器还是一次性的定时器只要调用invalidate方法则会变得无效，只是一次性的定时器执行完操作后会自动调用invalidate方法）。修改后的代码如下：</span><br><span class="line"></span><br><span class="line">```objc</span><br><span class="line">	#import &quot;ViewController1.h&quot;</span><br><span class="line">	</span><br><span class="line">	@interface ViewController1 ()</span><br><span class="line">	@property (nonatomic,weak) NSTimer *timer1;</span><br><span class="line">	@property (nonatomic,weak) NSTimer *timer2;</span><br><span class="line">	@end</span><br><span class="line">	</span><br><span class="line">	@implementation ViewController1</span><br><span class="line">	</span><br><span class="line">	- (void)viewDidLoad &#123;</span><br><span class="line">	    [super viewDidLoad];</span><br><span class="line">	    self.view.backgroundColor = [UIColor blueColor];</span><br><span class="line">	</span><br><span class="line">	    self.timer1 = [NSTimer scheduledTimerWithTimeInterval:1.0 repeats:YES block:^(NSTimer * _Nonnull timer) &#123;</span><br><span class="line">	        NSLog(@&quot;timer1...&quot;);</span><br><span class="line">	    &#125;];</span><br><span class="line">	    NSTimer *tempTimer = [NSTimer scheduledTimerWithTimeInterval:1.0 repeats:YES block:^(NSTimer * _Nonnull timer) &#123;</span><br><span class="line">	        NSLog(@&quot;timer2...&quot;);</span><br><span class="line">	    &#125;];</span><br><span class="line">	    [[NSRunLoop currentRunLoop] addTimer:tempTimer forMode:NSDefaultRunLoopMode];</span><br><span class="line">	    self.timer2 = tempTimer;</span><br><span class="line">	    </span><br><span class="line">	    CGRect rect = [UIScreen mainScreen].bounds;</span><br><span class="line">	    UIScrollView *scrollView = [[UIScrollView alloc] initWithFrame:CGRectInset(rect, 0, 200)];</span><br><span class="line">	    [self.view addSubview:scrollView];</span><br><span class="line">	    </span><br><span class="line">	    UIView *contentView = [[UIView alloc] initWithFrame:CGRectInset(scrollView.bounds, -100, -100)];</span><br><span class="line">	    contentView.backgroundColor = [UIColor redColor];</span><br><span class="line">	    [scrollView addSubview:contentView];</span><br><span class="line">	    scrollView.contentSize = contentView.frame.size;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	- (void)touchesBegan:(NSSet&lt;UITouch *&gt; *)touches withEvent:(UIEvent *)event &#123;</span><br><span class="line">	    [self dismissViewControllerAnimated:true completion:nil];</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	- (void)dealloc &#123;</span><br><span class="line">	    [self.timer1 invalidate];</span><br><span class="line">	    [self.timer2 invalidate];</span><br><span class="line">	    NSLog(@&quot;ViewController1 dealloc...&quot;);</span><br><span class="line">	&#125;</span><br><span class="line">	@end</span><br></pre></td></tr></table></figure>
<p>其实和定时器相关的另一个问题大家也经常碰到，那就是NSTimer不是一种实时机制，<a href="https://developer.apple.com/library/content/documentation/Cocoa/Conceptual/Timers/Articles/timerConcepts.html" target="_blank" rel="external">官方文档</a>明确说明在一个循环中如果RunLoop没有被识别（这个时间大概在50-100ms）或者说当前RunLoop在执行一个长的call out（例如执行某个循环操作）则NSTimer可能就会存在误差，RunLoop在下一次循环中继续检查并根据情况确定是否执行（NSTimer的执行时间总是固定在一定的时间间隔，例如1:00:00、1:00:01、1:00:02、1:00:05则跳过了第4、5次运行循环）。<br>要演示这个问题请看下面的例子（注意：有些示例中可能会让一个线程中启动一个定时器，再在主线程启动一个耗时任务来演示这个问，如果实际测试可能效果不会太明显，因为现在的iPhone都是多核运算的，这样一来这个问题会变得相对复杂，因此下面的例子选择在同一个RunLoop中即加入定时器和执行耗时任务）</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#import <span class="meta-string">"ViewController.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">ViewController</span> ()</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>,<span class="keyword">weak</span>) <span class="built_in">NSTimer</span> *timer1;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>,<span class="keyword">strong</span>) <span class="built_in">NSThread</span> *thread1;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">ViewController</span></span></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)viewDidLoad &#123;</span><br><span class="line">    [<span class="keyword">super</span> viewDidLoad];</span><br><span class="line">    <span class="keyword">self</span>.view.backgroundColor = [<span class="built_in">UIColor</span> redColor];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 由于下面的方法无法拿到NSThread的引用，也就无法控制线程的状态</span></span><br><span class="line">    <span class="comment">//[NSThread detachNewThreadSelector:@selector(performTask) toTarget:self withObject:nil];</span></span><br><span class="line">    <span class="keyword">self</span>.thread1 = [[<span class="built_in">NSThread</span> alloc] initWithTarget:<span class="keyword">self</span> selector:<span class="keyword">@selector</span>(performTask) object:<span class="literal">nil</span>];</span><br><span class="line">    [<span class="keyword">self</span>.thread1 start];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)touchesBegan:(<span class="built_in">NSSet</span>&lt;<span class="built_in">UITouch</span> *&gt; *)touches withEvent:(<span class="built_in">UIEvent</span> *)event &#123;</span><br><span class="line">    [<span class="keyword">self</span>.thread1 cancel];</span><br><span class="line">    [<span class="keyword">self</span> dismissViewControllerAnimated:<span class="literal">YES</span> completion:<span class="literal">nil</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)dealloc &#123;</span><br><span class="line">    [<span class="keyword">self</span>.timer1 invalidate];</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"ViewController dealloc."</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)performTask &#123;</span><br><span class="line">    <span class="comment">// 使用下面的方式创建定时器虽然会自动加入到当前线程的RunLoop中，但是除了主线程外其他线程的RunLoop默认是不会运行的，必须手动调用</span></span><br><span class="line">    __<span class="keyword">weak</span> <span class="keyword">typeof</span>(<span class="keyword">self</span>) weakSelf = <span class="keyword">self</span>;</span><br><span class="line">    <span class="keyword">self</span>.timer1 = [<span class="built_in">NSTimer</span> scheduledTimerWithTimeInterval:<span class="number">1.0</span> repeats:<span class="literal">YES</span> block:^(<span class="built_in">NSTimer</span> * _Nonnull timer) &#123;</span><br><span class="line">        <span class="keyword">if</span> ([<span class="built_in">NSThread</span> currentThread].isCancelled) &#123;</span><br><span class="line">            <span class="comment">//[NSObject cancelPreviousPerformRequestsWithTarget:weakSelf selector:@selector(caculate) object:nil];</span></span><br><span class="line">            <span class="comment">//[NSThread exit];</span></span><br><span class="line">            [weakSelf.timer1 invalidate];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"timer1..."</span>);</span><br><span class="line">    &#125;];</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"runloop before performSelector:%@"</span>,[<span class="built_in">NSRunLoop</span> currentRunLoop]);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 区分直接调用和「performSelector:withObject:afterDelay:」区别,下面的直接调用无论是否运行RunLoop一样可以执行，但是后者则不行。</span></span><br><span class="line">    <span class="comment">//[self caculate];</span></span><br><span class="line">    [<span class="keyword">self</span> performSelector:<span class="keyword">@selector</span>(caculate) withObject:<span class="literal">nil</span> afterDelay:<span class="number">2.0</span>];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 取消当前RunLoop中注册测selector（注意：只是当前RunLoop，所以也只能在当前RunLoop中取消）</span></span><br><span class="line">    <span class="comment">// [NSObject cancelPreviousPerformRequestsWithTarget:self selector:@selector(caculate) object:nil];</span></span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"runloop after performSelector:%@"</span>,[<span class="built_in">NSRunLoop</span> currentRunLoop]);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 非主线程RunLoop必须手动调用</span></span><br><span class="line">    [[<span class="built_in">NSRunLoop</span> currentRunLoop] run];</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"注意：如果RunLoop不退出（运行中），这里的代码并不会执行，RunLoop本身就是一个循环."</span>);</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)caculate &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; <span class="number">9999</span>;++i) &#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"%i,%@"</span>,i,[<span class="built_in">NSThread</span> currentThread]);</span><br><span class="line">        <span class="keyword">if</span> ([<span class="built_in">NSThread</span> currentThread].isCancelled) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
<p>如果运行并且不退出上面的程序会发现，前两秒NSTimer可以正常执行，但是两秒后由于同一个RunLoop中循环操作的执行造成定时器跳过了中间执行的机会一直到<strong>caculator</strong>循环完毕，这也正说明了NSTimer不是实时系统机制的原因。</p>
<p>但是以上程序还有几点需要说明一下：</p>
<ol>
<li>NSTimer会对Target进行强引用直到任务结束或exit之后才会释放。如果上面的程序没有进行线程cancel而终止任务则及时关闭控制器也无法正确释放。</li>
<li>非主线程的RunLoop并不会自动运行（同时注意默认情况下非主线程的RunLoop并不会自动创建，直到第一次使用），RunLoop运行必须要在加入NSTimer或Source0、Sourc1、Observer输入后运行否则会直接退出。例如上面代码如果<strong>run</strong>放到NSTimer创建之前则既不会执行定时任务也不会执行循环运算。</li>
<li><strong>performSelector:withObject:afterDelay:</strong>执行的本质还是通过创建一个NSTimer然后加入到当前线程RunLoop（通而过前后两次打印RunLoop信息可以看到此方法执行之后RunLoop的timer会增加1个。类似的还有<strong>performSelector:onThread:withObject:afterDelay:</strong>，只是它会在另一个线程的RunLoop中创建一个Timer），所以此方法事实上在任务执行完之前会对触发对象形成引用，任务执行完进行释放（例如上面会对ViewController形成引用，注意：<strong>performSelector: withObject:</strong>等方法则等同于直接调用，原理与此不同）。</li>
<li>同时上面的代码也充分说明了RunLoop是一个循环事实，run方法之后的代码不会立即执行，直到RunLoop退出。</li>
<li>上面程序的运行过程中如果突然<strong>dismiss</strong>，则程序的实际执行过程要分为两种情况考虑：如果循环任务caculate还没有开始则会在timer1中停止timer1运行（停止了线程中第一个任务），然后等待caculate执行并break（停止线程中第二个任务）后线程任务执行结束释放对控制器的引用；如果循环任务caculate执行过程中dismiss则caculate任务执行结束，等待timer1下个周期运行（因为当前线程的RunLoop并没有退出，timer1引用计数器并不为0）时检测到线程取消状态则执行invalidate方法（第二个任务也结束了），此时线程释放对于控制器的引用。</li>
</ol>
<blockquote>
<p>CADisplayLink是一个执行频率（fps）和屏幕刷新相同（可以修改preferredFramesPerSecond改变刷新频率）的定时器，它也需要加入到RunLoop才能执行。与NSTimer类似，CADisplayLink同样是基于CFRunloopTimerRef实现，底层使用mk_timer（可以比较加入到RunLoop前后RunLoop中timer的变化）。和NSTimer相比它精度更高（尽管NSTimer也可以修改精度），不过和NStimer类似的是如果遇到大任务它仍然存在丢帧现象。通常情况下CADisaplayLink用于构建帧动画，看起来相对更加流畅，而NSTimer则有更广泛的用处。</p>
</blockquote>
<h2 id="AutoreleasePool"><a href="#AutoreleasePool" class="headerlink" title="AutoreleasePool"></a>AutoreleasePool</h2><p>AutoreleasePool是另一个与RunLoop相关讨论较多的话题。其实从RunLoop源代码分析，AutoreleasePool与RunLoop并没有直接的关系，之所以将两个话题放到一起讨论最主要的原因是因为在iOS应用启动后会注册两个Observer管理和维护AutoreleasePool。不妨在应用程序刚刚启动时打印<strong>currentRunLoop</strong>可以看到系统默认注册了很多个Observer，其中有两个Observer的callout都是<strong> _ wrapRunLoopWithAutoreleasePoolHandler</strong>，这两个是和自动释放池相关的两个监听。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;CFRunLoopObserver 0x6080001246a0 [0x101f81df0]&gt;&#123;valid = Yes, activities = 0x1, repeats = Yes, order = -2147483647, callout = _wrapRunLoopWithAutoreleasePoolHandler (0x1020e07ce), context = &lt;CFArray 0x60800004cae0 [0x101f81df0]&gt;&#123;type = mutable-small, count = 0, values = ()&#125;&#125;</span><br><span class="line">'' &lt;CFRunLoopObserver 0x608000124420 [0x101f81df0]&gt;&#123;valid = Yes, activities = 0xa0, repeats = Yes, order = 2147483647, callout = _wrapRunLoopWithAutoreleasePoolHandler (0x1020e07ce), context = &lt;CFArray 0x60800004cae0 [0x101f81df0]&gt;&#123;type = mutable-small, count = 0, values = ()&#125;&#125;</span><br></pre></td></tr></table></figure>
<p>第一个Observer会监听RunLoop的进入，它会回调<strong>objc_autoreleasePoolPush()</strong>向当前的<strong>AutoreleasePoolPage</strong>增加一个哨兵对象标志创建自动释放池。这个Observer的order是-2147483647优先级最高，确保发生在所有回调操作之前。<br>第二个Observer会监听RunLoop的进入休眠和即将退出RunLoop两种状态，在即将进入休眠时会调用<strong>objc_autoreleasePoolPop() </strong>和 <strong>objc_autoreleasePoolPush() </strong>根据情况从最新加入的对象一直往前清理直到遇到哨兵对象。而在即将退出RunLoop时会调用<strong>objc_autoreleasePoolPop() </strong>释放自动自动释放池内对象。这个Observer的order是2147483647，优先级最低，确保发生在所有回调操作之后。<br>主线程的其他操作通常均在这个AutoreleasePool之内（main函数中），以尽可能减少内存维护操作(当然你如果需要显式释放【例如循环】时可以自己创建AutoreleasePool否则一般不需要自己创建)。<br>其实在应用程序启动后系统还注册了其他Observer（例如即将进入休眠时执行注册回调_UIGestureRecognizerUpdateObserver用于手势处理、回调为_ZN2CA11Transaction17observer_callbackEP19__CFRunLoopObservermPv的Observer用于界面实时绘制更新）和多个Source1（例如context为CFMachPort的Source1用于接收硬件事件响应进而分发到应用程序一直到UIEvent），这里不再一一详述。</p>
<h2 id="UI更新"><a href="#UI更新" class="headerlink" title="UI更新"></a>UI更新</h2><p>如果打印App启动之后的主线程RunLoop可以发现另外一个callout为<strong>_ZN2CA11Transaction17observer_callbackEP19__CFRunLoopObservermPv</strong>的Observer，这个监听专门负责UI变化后的更新，比如修改了frame、调整了UI层级（UIView/CALayer）或者手动设置了setNeedsDisplay/setNeedsLayout之后就会将这些操作提交到全局容器。而这个Observer监听了主线程RunLoop的即将进入休眠和退出状态，一旦进入这两种状态则会遍历所有的UI更新并提交进行实际绘制更新。<br>通常情况下这种方式是完美的，因为除了系统的更新，还可以利用setNeedsDisplay等方法手动触发下一次RunLoop运行的更新。但是如果当前正在执行大量的逻辑运算可能UI的更新就会比较卡，因此facebook推出了<a href="https://github.com/facebookarchive/AsyncDisplayKit" target="_blank" rel="external">AsyncDisplayKit</a>来解决这个问题。AsyncDisplayKit其实是将UI排版和绘制运算尽可能放到后台，将UI的最终更新操作放到主线程（这一步也必须在主线程完成），同时提供一套类UIView或CALayer的相关属性，尽可能保证开发者的开发习惯。这个过程中AsyncDisplayKit在主线程RunLoop中增加了一个Observer监听即将进入休眠和退出RunLoop两种状态,收到回调时遍历队列中的待处理任务一一执行。</p>
<h2 id="NSURLConnection"><a href="#NSURLConnection" class="headerlink" title="NSURLConnection"></a>NSURLConnection</h2><p>在前面的<a href="http://www.cnblogs.com/kenshincui/p/4042190.html#requestAndResponse" target="_blank" rel="external">网络开发</a>的文章中已经介绍过NSURLConnection的使用，一旦启动NSURLConnection以后就会不断调用delegate方法接收数据，这样一个连续的的动作正是基于RunLoop来运行。<br>一旦NSURLConnection设置了delegate会立即创建一个线程<strong>com.apple.NSURLConnectionLoader</strong>，同时内部启动RunLoop并在NSDefaultMode模式下添加4个Source0。其中CFHTTPCookieStorage用于处理cookie ;CFMultiplexerSource负责各种delegate回调并在回调中唤醒delegate内部的RunLoop（通常是主线程）来执行实际操作。<br>早期版本的AFNetworking库也是基于NSURLConnection实现，为了能够在后台接收delegate回调AFNetworking内部创建了一个空的线程并启动了RunLoop，当需要使用这个后台线程执行任务时AFNetworking通过<strong>performSelector: onThread: </strong>将这个任务放到后台线程的RunLoop中。 </p>
<h2 id="GCD和RunLoop的关系"><a href="#GCD和RunLoop的关系" class="headerlink" title="GCD和RunLoop的关系"></a>GCD和RunLoop的关系</h2><p>在RunLoop的源代码中可以看到用到了GCD的相关内容，但是RunLoop本身和GCD并没有直接的关系。当调用了dispatch_async(dispatch_get_main_queue(), \&lt;#^(void)block#>)时libDispatch会向主线程RunLoop发送消息唤醒RunLoop，RunLoop从消息中获取block，并且在<strong>CFRUNLOOP_IS_SERVICING_THE_MAIN_DISPATCH_QUEUE</strong>回调里执行这个block。不过这个操作仅限于主线程，其他线程dispatch操作是全部由libDispatch驱动的。</p>
<h2 id="更多RunLoop使用"><a href="#更多RunLoop使用" class="headerlink" title="更多RunLoop使用"></a>更多RunLoop使用</h2><p>前面看了很多RunLoop的系统应用和一些知名第三方库使用，那么除了这些究竟在实际开发过程中我们自己能不能适当的使用RunLoop帮我们做一些事情呢？</p>
<p>思考这个问题其实只要看RunLoopRef的包含关系就知道了，RunLoop包含多个Mode，而它的Mode又是可以自定义的，这么推断下来其实无论是Source1、Timer还是Observer开发者都可以利用，但是通常情况下不会自定义Timer，更不会自定义一个完整的Mode，利用更多的其实是Observer和Mode的切换。<br>例如很多人都熟悉的使用perfromSelector在默认模式下设置图片，防止UITableView滚动卡顿（[[<a href="#">UIImageView alloc</a> initWithFrame:CGRectMake(0, 0, 100, 100)] performSelector:@selector(setImage:) withObject:myImage afterDelay:0.0 inModes:@<a href="#">NSDefaultRunLoopMode</a>]）。还有sunnyxx的<a href="https://github.com/forkingdog/UITableView-FDTemplateLayoutCell" target="_blank" rel="external">UITableView+FDTemplateLayoutCell</a>利用Observer在界面空闲状态下计算出UITableViewCell的高度并进行缓存。再有老谭的<a href="http://storage.tanhao.me/2015/11/PerformanceMonitor.zip" target="_blank" rel="external">PerformanceMonitor</a>关于iOS实时卡顿监控，同样是利用Observer对RunLoop进行监视。</p>
<blockquote>
<p>关于如何自定义一个Custom Input Source<a href="https://developer.apple.com/library/content/documentation/Cocoa/Conceptual/Multithreading/RunLoopManagement/RunLoopManagement.html#//apple_ref/doc/uid/10000057i-CH16-SW3" target="_blank" rel="external">官网</a>给出了详细的流程。</p>
</blockquote>
<!--注意本文说的Runloop指的是通常意义上大家讨论的运行循环并不指特定的对象或者函数。只有CFRunloopRef(__CFRunLoop)或者__CFRunloopRun()才是只的具体的运行循环的对象或函数。
-->

  </section>

</article>

<section class="read-more">
           
    
               
            <div class="read-more-item">
                <span class="read-more-item-dim">最近的文章</span>
                <h2 class="post-list__post-title post-title"><a href="/2017/06/05/iOS架构设计-URL缓存/" title="iOS架构设计-URL缓存">iOS架构设计-URL缓存</a></h2>
                <p class="excerpt">
                
                概览缓存组件应该说是每个客户端程序必备的核心组件，试想对于每个界面的访问都必须重新请求势必降低用户体验。但是如何处理客户端缓存貌似并没有统一的解决方案，多数开发者选择自行创建数据库直接将服务器端请求的JSON（或Model）缓存起来，下次请求则查询数据库检查缓存是否存在；另外还有些开发者会选择以归档
                &hellip;
                </p>
                <div class="post-list__meta"><time datetime="2017-06-05T07:53:20.000Z" class="post-list__meta--date date">2017-06-05</time> &#8226; <span class="post-list__meta--tags tags">于&nbsp;
  <a class="tag-link" href="/tags/NSURLCache-AlamofireURLCache-NSURLProtocol/">NSURLCache,AlamofireURLCache,NSURLProtocol</a>
</span><a class="btn-border-small" href="/2017/06/05/iOS架构设计-URL缓存/">继续阅读</a></div>
                           
            </div>
        
        
               
            <div class="read-more-item">
                <span class="read-more-item-dim">更早的文章</span>
                <h2 class="post-list__post-title post-title"><a href="/2017/05/07/iOS开发tips-UINavigationBar的切换/" title="iOS开发tips-UINavigationBar的切换">iOS开发tips-UINavigationBar的切换</a></h2>
                <p class="excerpt">
                
                概述在iOS系统中，如果控制器是以push方式进行管理的话，那么事实上多个控制器是共享的同一个导航栏。当然iOS系统的设计无可厚非，但是国内的应用经常会遇到很多个性的设计，就比如说A push到 B，A可能有导航栏，但是B控制器要求导航栏是透明的，这样一来A和B由于共用同一个导航栏就会让整个切换操作
                &hellip;
                </p>
                <div class="post-list__meta"><time datetime="2017-05-07T02:56:23.000Z" class="post-list__meta--date date">2017-05-07</time> &#8226; <span class="post-list__meta--tags tags">于&nbsp;
  <a class="tag-link" href="/tags/UINavigationBar/">UINavigationBar</a>
</span><a class="btn-border-small" href="/2017/05/07/iOS开发tips-UINavigationBar的切换/">继续阅读</a></div>
                       
            </div>
        
     
   
   
  
</section>

  
<section class="post-comments">
  <div id="disqus_thread"></div>
  <script type="text/javascript">
      var disqus_shortname = 'kenshincui'; 
      
  var disqus_identifier = '/2017/05/08/iOS刨根问底-深入理解RunLoop/';
  var disqus_title = 'iOS刨根问底-深入理解RunLoop';
  var disqus_url = 'http://yoursite.com/2017/05/08/iOS刨根问底-深入理解RunLoop/';
  

      /* * * DON'T EDIT BELOW THIS LINE * * */
      (function() {
          var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
          //dsq.src = 'https://' + disqus_shortname + '.disqus.com/embed.js';
          dsq.src = 'https://a.disquscdn.com/embed.js';
          (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
      })();
  </script>
  <noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
  <a href="https://disqus.com" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a>
</section>


            <footer class="footer">
    <span class="footer__copyright">
        本站点采用 <a href="http://creativecommons.org/licenses/by-nc-sa/4.0/">知识共享署名-非商业性使用-相同方式共享 4.0 国际许可协议</a>
    </span>
    <span class="footer__copyright">
        基于 <a href="http://hexo.io">Hexo</a> 搭建，感谢 <a href="https://pages.github.com/">GitHub Pages</a> 提供免费的托管服务
    </span>
    <span class="footer__copyright">
        &copy; 2017 - 本站使用 <a href="https://github.com/monniya/hexo-theme-new-vno ">new-vno</a> 主题,
        由<a href="https://monniya.com ">@Monniya</a> 修改自 <a href="https://github.com/lenbo-ma/hexo-theme-vno" target="_blank">Vno</a>, 原创出自<a href="http://github.com/onevcat/vno" target="_blank">onevcat</a>
    </span>
    
</footer>


        </div>
    </div>

     
    


    <script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    
    
</body>
</html>
