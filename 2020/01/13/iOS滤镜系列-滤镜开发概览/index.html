<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8"/>
    <meta http-equiv="X-UA-Compatible" content="IE=edge"/>
    
    <title>iOS滤镜系列-滤镜开发概览 | Kenshin Cui&#39;s Blog</title>
    <meta name="renderer" content="webkit">
    <meta name="HandheldFriendly" content="True">
    <meta name="MobileOptimized" content="320">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

    <meta name="description" content="iOS Developer">

    <meta name="twitter:card" content="summary">
    <meta name="twitter:title" content="iOS滤镜系列-滤镜开发概览 | Kenshin Cui&#39;s Blog">
    <meta name="twitter:description" content="iOS Developer">

    <meta property="og:type" content="article">
    <meta property="og:title" content="iOS滤镜系列-滤镜开发概览 | Kenshin Cui&#39;s Blog">
    <meta property="og:description" content="iOS Developer">

    
    <meta name="author" content="Kenshin Cui">
    
    <link rel="stylesheet" href="/css/vno.css">
    <link rel="stylesheet" href="//netdna.bootstrapcdn.com/font-awesome/4.1.0/css/font-awesome.min.css">

    
    <link rel="icon" href="/favicon.ico">
    

    <meta name="generator" content="hexo"/>
    

    <link rel="canonical" href="http://yoursite.com/2020/01/13/iOS滤镜系列-滤镜开发概览/"/>

                 
</head>

<body class="home-template no-js">
    <script src="//cdn.bootcss.com/jquery/2.1.4/jquery.min.js"></script>
    <script src="/js/main.js"></script>
    <span class="mobile btn-mobile-menu">
        <i class="fa fa-list btn-mobile-menu__icon"></i>
        <i class="fa fa-angle-up btn-mobile-close__icon hidden"></i>
    </span>

    
<header class="panel-cover panel-cover--collapsed" style="background-image: url(/images/background-cover.jpg)">
  <div class="panel-main">
    <div class="panel-main__inner panel-inverted">
    <div class="panel-main__content">

        <a href="/" title="前往 Kenshin Cui&#39;s Blog 的主页"><img src="/images/avatar.jpg" width="80" alt="Kenshin Cui&#39;s Blog logo" class="panel-cover__logo logo" /></a>
        <h1 class="panel-cover__title panel-title"><a href="/" title="link to homepage for Kenshin Cui&#39;s Blog">Kenshin Cui&#39;s Blog</a></h1>
        
        <span class="panel-cover__subtitle panel-subtitle">即便是别人看不到的地方, 对其工艺也必须尽心尽力。</span>
        
        <hr class="panel-cover__divider" />
        <p class="panel-cover__description">iOS Developer</p>
        <hr class="panel-cover__divider panel-cover__divider--secondary" />

        <div class="navigation-wrapper">
          <div>
          <nav class="cover-navigation cover-navigation--primary">
            <ul class="navigation">
              <li class="navigation__item"><a href="/#blog" title="访问博客" class="blog-button">博客</a></li>
            
              <li class="navigation__item"><a href="/archive">归档</a></li>
            
              <li class="navigation__item"><a href="/about">关于</a></li>
            
            </ul>
          </nav>
          </div>
          <div>
          <nav class="cover-navigation navigation--social">
  <ul class="navigation">

  <!-- Weibo-->
  

  <!-- Github -->
  
  <li class="navigation__item">
    <a href="https://github.com/kenshincui" title="查看我的GitHub主页" target="_blank">
      <i class='social fa fa-github'></i>
      <span class="label">Github</span>
    </a>
  </li>


<!-- Stack Overflow -->
        

  <!-- Google Plus -->
  

<!-- Facebook -->

  
<!-- Twitter -->

  



  </ul>
</nav>

          </div>
        </div>

      </div>

    </div>

    <div class="panel-cover--overlay cover-green"></div>
  </div> 
</header>

    <div class="content-wrapper">
        <div class="content-wrapper__inner">
            <article class="post-container post-container--single">

  <header class="post-header">
    <div class="post-meta">
      <time datetime="2020-01-13T07:53:20.000Z" class="post-list__meta--date date">2020-01-13</time> &#8226; <span class="post-meta__tags tags">于&nbsp;
  <a class="tag-link" href="/tags/OpenGL-GPUImage-OpenCV-Core-Image-Metal/">OpenGL , GPUImage , OpenCV , Core Image , Metal</a>
 </span>
      <span class="page-pv">
      &nbsp;阅读&nbsp;<span id="busuanzi_value_page_pv"><i class="fa fa-spinner fa-spin"></i></span>
      </span> 
   
    </div>
    <h1 class="post-title">iOS滤镜系列-滤镜开发概览</h1>
  </header>

  <section class="post">
    <p><img src="https://i.loli.net/2020/01/12/dL3t6E9yzojCVDK.png" alt="filter-logo"></p>
<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>滤镜最早的出现应该是应用在相机镜头前实现自然光过滤和调色的镜片，然而在软件开发中更多的指的是软件滤镜，是对镜头滤镜的模拟实现。当然这种方式更加方便快捷，缺点自然就是无法还原拍摄时的真实场景，例如无法实现偏光镜和紫外线滤色镜的效果。今天简单介绍一下iOS滤镜开发中的正确姿势，让刚刚接触滤镜开发的朋友少走弯路。</p>
<p>在iOS开发中常见的滤镜开发方式大概包括：CIFilter、GPUImage、OpenCV等。</p>
<h1 id="CoreImage"><a href="#CoreImage" class="headerlink" title="CoreImage"></a>CoreImage</h1><p><img src="https://i.loli.net/2020/01/12/GlKkFTxMXZvrS6D.png" alt="core_image"></p>
<h2 id="CIFilter"><a href="#CIFilter" class="headerlink" title="CIFilter"></a>CIFilter</h2><p>CIFilter存在于CoreImage框架中，它基于OpenGL着色器来处理图像（最新的已经基于Metal实现），优点当然是快，因为它可以充分利用GPU加速来处理图像渲染，同时它自身支持滤镜链，多个滤镜同时使用时迅速高效。</p>
<p>CIFilter目前已经支持21个分类（如下代码）<a href="https://developer.apple.com/library/archive/documentation/GraphicsImaging/Reference/CoreImageFilterReference/index.html#//apple_ref/doc/uid/TP40004346" target="_blank" rel="external">196种滤镜</a>：<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">let</span> kCICategoryDistortionEffect: <span class="type">String</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">let</span> kCICategoryGeometryAdjustment: <span class="type">String</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">let</span> kCICategoryCompositeOperation: <span class="type">String</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">let</span> kCICategoryHalftoneEffect: <span class="type">String</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">let</span> kCICategoryColorAdjustment: <span class="type">String</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">let</span> kCICategoryColorEffect: <span class="type">String</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">let</span> kCICategoryTransition: <span class="type">String</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">let</span> kCICategoryTileEffect: <span class="type">String</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">let</span> kCICategoryGenerator: <span class="type">String</span></span><br><span class="line"><span class="meta">@available</span>(iOS <span class="number">5.0</span>, *)</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">let</span> kCICategoryReduction: <span class="type">String</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">let</span> kCICategoryGradient: <span class="type">String</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">let</span> kCICategoryStylize: <span class="type">String</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">let</span> kCICategorySharpen: <span class="type">String</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">let</span> kCICategoryBlur: <span class="type">String</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">let</span> kCICategoryVideo: <span class="type">String</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">let</span> kCICategoryStillImage: <span class="type">String</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">let</span> kCICategoryInterlaced: <span class="type">String</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">let</span> kCICategoryNonSquarePixels: <span class="type">String</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">let</span> kCICategoryHighDynamicRange: <span class="type">String</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">let</span> kCICategoryBuiltIn: <span class="type">String</span></span><br><span class="line"><span class="meta">@available</span>(iOS <span class="number">9.0</span>, *)</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">let</span> kCICategoryFilterGenerator: <span class="type">String</span></span><br></pre></td></tr></table></figure></p>
<p>使用<code>open class func filterNames(inCategory category: String?) -&gt; [String]</code>可以查看每个分类的滤镜名称。而每个滤镜的属性设置通过CIFilter的<strong>attributes</strong>就可以查看。而应用一个CIFilter滤镜也仅仅需要：创建滤镜-&gt;设置属性（KVC）-&gt;读取输入图片（下面演示了高斯模糊滤镜的简单实现）：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">guard</span> <span class="keyword">let</span> cgImage = <span class="type">UIImage</span>(named:<span class="string">"CIFilter_Demo_Origin"</span>)?.cgImage <span class="keyword">else</span> &#123; <span class="keyword">return</span> &#125;</span><br><span class="line">        <span class="keyword">let</span> ciImage = <span class="type">CIImage</span>(cgImage: cgImage)</span><br><span class="line">        <span class="keyword">let</span> <span class="built_in">filter</span> = <span class="type">CIFilter</span>(name: <span class="string">"CIGaussianBlur"</span>)</span><br><span class="line">        <span class="built_in">filter</span>?.setValue(ciImage, forKey: kCIInputImageKey)</span><br><span class="line">        <span class="built_in">filter</span>?.setValue(<span class="number">5.0</span>, forKey: <span class="string">"inputRadius"</span>)</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">let</span> outputImage = <span class="built_in">filter</span>?.value(forKeyPath: kCIOutputImageKey) <span class="keyword">as</span>? <span class="type">CIImage</span> &#123;</span><br><span class="line">            <span class="keyword">let</span> context = <span class="type">CIContext</span>()</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">let</span> cgImage = context.createCGImage(outputImage, from: outputImage.extent) &#123;</span><br><span class="line">                <span class="keyword">let</span> image = <span class="type">UIImage</span>(cgImage: cgImage)</span><br><span class="line">                <span class="type">UIImageWriteToSavedPhotosAlbum</span>(image, <span class="literal">nil</span>, <span class="literal">nil</span>, <span class="literal">nil</span>)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>
<p>原图</p>
<p><img src="https://i.loli.net/2020/01/12/u4ZBwv5aVJ3GhtL.jpg" alt="CIFilter_Demo_Origin"></p>
<p>应用高斯模糊</p>
<p><img src="https://i.loli.net/2020/01/12/745dQEVcakSnjN1.jpg" alt="CIFilter_Demo_Gauss"></p>
<blockquote>
<p>滤镜链<br>所谓滤镜链就是将一个滤镜A的输出作为另一个滤镜B的输入形成有向图，使用这种方式Core Image并非一步步执行结果应用到B滤镜，而是将多个滤镜的着色器合并操作，从而提高性能。<br>例如在上面的高斯模糊滤镜基础上应用像素化滤镜:<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="keyword">guard</span> <span class="keyword">let</span> cgImage = <span class="type">UIImage</span>(named:<span class="string">"CIFilter_Demo_Origin"</span>)?.cgImage <span class="keyword">else</span> &#123; <span class="keyword">return</span> &#125;</span><br><span class="line">&gt;         <span class="keyword">let</span> ciImage = <span class="type">CIImage</span>(cgImage: cgImage)</span><br><span class="line">&gt;         <span class="keyword">let</span> blurFilter = <span class="type">CIFilter</span>(name: <span class="string">"CIGaussianBlur"</span>)</span><br><span class="line">&gt;         blurFilter?.setValue(ciImage, forKey: kCIInputImageKey)</span><br><span class="line">&gt;         blurFilter?.setValue(<span class="number">5.0</span>, forKey: <span class="string">"inputRadius"</span>)</span><br><span class="line">&gt;         </span><br><span class="line">&gt;         <span class="keyword">let</span> pixelFilter = <span class="type">CIFilter</span>(name: <span class="string">"CIPixellate"</span>, parameters: [kCIInputImageKey:blurFilter!.outputImage!])</span><br><span class="line">&gt;         pixelFilter?.setDefaults()</span><br><span class="line">&gt;         </span><br><span class="line">&gt;         <span class="keyword">if</span> <span class="keyword">let</span> outputImage = pixelFilter?.outputImage &#123;</span><br><span class="line">&gt;             <span class="keyword">let</span> context = <span class="type">CIContext</span>()</span><br><span class="line">&gt;             <span class="keyword">if</span> <span class="keyword">let</span> cgImage = context.createCGImage(outputImage, from: outputImage.extent) &#123;</span><br><span class="line">&gt;                 <span class="keyword">let</span> image = <span class="type">UIImage</span>(cgImage: cgImage)</span><br><span class="line">&gt;                 <span class="type">UIImageWriteToSavedPhotosAlbum</span>(image, <span class="literal">nil</span>, <span class="literal">nil</span>, <span class="literal">nil</span>)</span><br><span class="line">&gt;             &#125;</span><br><span class="line">&gt;         &#125;</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></p>
<p>另外新的API（iOS 11）如果使用滤镜建议使用更加直观的表达以简化书写：<code>let outputImage = ciImage.applyingFilter(&quot;CIGaussianBlur&quot;, parameters: [kCIInputRadiusKey:5.0]).applyingFilter(&quot;CIPixellate&quot;)</code><br>此外说到CoreImage的高斯模糊时直接使用是有一个问题的，那就是radius越大越会产生一个明显的空白边缘，当然这个问题是因为滤镜的卷积操作通常从中心点开始应用造成的，这样就会致使边缘上的像素值不能得到有效应用，类似于OpenCV会自己处理这个问题，但是Core Image并没有处理这个边缘问题，通常的处理方法就是放大图片，然后剪切到原来的图片大小即可(其实就是在滤镜前后分别调用clampedToExtend()获取一个边缘扩展的图像，应用滤镜之后调用croped()获取一个裁剪边缘的图像即可)。<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="keyword">guard</span> <span class="keyword">let</span> cgImage = <span class="type">UIImage</span>(named:<span class="string">"CIFilter_Demo_Origin"</span>)?.cgImage <span class="keyword">else</span> &#123; <span class="keyword">return</span> &#125;</span><br><span class="line">&gt;         <span class="keyword">let</span> ciImage = <span class="type">CIImage</span>(cgImage: cgImage)</span><br><span class="line">&gt;         <span class="keyword">let</span> outputImage = ciImage.clampedToExtent().applyingFilter(<span class="string">"CIGaussianBlur"</span>, parameters: [kCIInputRadiusKey:<span class="number">5.0</span>]).cropped(to: ciImage.extent)</span><br><span class="line">&gt;         <span class="keyword">let</span> context = <span class="type">CIContext</span>()</span><br><span class="line">&gt;         <span class="keyword">if</span> <span class="keyword">let</span> cgImage = context.createCGImage(outputImage, from: ciImage.extent) &#123;</span><br><span class="line">&gt;             <span class="keyword">let</span> image = <span class="type">UIImage</span>(cgImage: cgImage)</span><br><span class="line">&gt;             <span class="type">UIImageWriteToSavedPhotosAlbum</span>(image, <span class="literal">nil</span>, <span class="literal">nil</span>, <span class="literal">nil</span>)</span><br><span class="line">&gt;         &#125;</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></p>
</blockquote>
<h2 id="自定义算子"><a href="#自定义算子" class="headerlink" title="自定义算子"></a>自定义算子</h2><p>尽管Core Image提供了不少滤镜可以使用，不过实际开发中还并不能够满足需求，比如说描绘边缘这个操作在Core Image中应该就没有提供直接的滤镜。而有不少滤镜是通过卷积操作完成的，只要提供一个算子就可以形成一个新的滤镜效果，事实上Core Image框架也提供了这个滤镜：<strong>CIConvolution3X3</strong>和<strong>CIConvolution5X5</strong>。这两个滤镜支持开发者自定义算子实现一个滤镜操作，下面是使用CIConvolution3X3实现的sobel算子提取边缘的滤镜：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">guard</span> <span class="keyword">let</span> cgImage = <span class="type">UIImage</span>(named:<span class="string">"CIFilter_Demo_Origin"</span>)?.cgImage <span class="keyword">else</span> &#123; <span class="keyword">return</span> &#125;</span><br><span class="line">        <span class="keyword">let</span> ciImage = <span class="type">CIImage</span>(cgImage: cgImage)</span><br><span class="line">        <span class="keyword">let</span> sobel:[<span class="type">CGFloat</span>] = [-<span class="number">1</span>,<span class="number">0</span>,<span class="number">1</span>,-<span class="number">2</span>,<span class="number">0</span>,<span class="number">2</span>,-<span class="number">1</span>,<span class="number">0</span>,<span class="number">1</span>]</span><br><span class="line">        <span class="keyword">let</span> weight = <span class="type">CIVector</span>(values: sobel, <span class="built_in">count</span>: <span class="number">9</span>)</span><br><span class="line">        <span class="keyword">let</span> outputImage = ciImage.applyingFilter(<span class="string">"CIConvolution3X3"</span>, parameters: [kCIInputWeightsKey:weight,kCIInputBiasKey:<span class="number">0.5</span>])</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">let</span> context = <span class="type">CIContext</span>()</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">let</span> cgImage = context.createCGImage(outputImage, from: ciImage.extent) &#123;</span><br><span class="line">            <span class="keyword">let</span> image = <span class="type">UIImage</span>(cgImage: cgImage)</span><br><span class="line">            <span class="type">UIImageWriteToSavedPhotosAlbum</span>(image, <span class="literal">nil</span>, <span class="literal">nil</span>, <span class="literal">nil</span>)</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>
<p>前面的图应用Sobel算子后的效果：</p>
<p><img src="https://i.loli.net/2020/01/12/qEY1uWoVrCB7TNe.jpg" alt="CIFilter_Demo_Sobel"></p>
<p>可以看出来边缘已经被提取出来，其实无论是CIConvolution3X3还是CIConvolution5X5都只是进行一个卷积操作，本质就是对应的像素分别乘以对应算子上的值最后相加等于产生一个新的值作为当前像素的值（这个值通常是待处理图像区块中心）如下图：</p>
<p><img src="https://i.loli.net/2020/01/12/Arf4CVdZLS6z7jW.jpg" alt="sobel_demo"></p>
<p>除了上面的Sobel算子，常见的算子还有锐化算子{0,-1,0,-1,5,-1,0,-1,0}、浮雕算子{1,0,0,0,0,0,0,0,-1}、拉普拉斯算子（边缘检测）{0,1,0,1,-4,1,0,1,0}等等。</p>
<h2 id="自定义滤镜"><a href="#自定义滤镜" class="headerlink" title="自定义滤镜"></a>自定义滤镜</h2><p>如果仅仅是自定义算子恐怕还不能体现出CIFilter的强大之处，毕竟不少滤镜通过特定算子还是无法满足的，CIFilter支持自定义片段着色器实现自己的滤镜效果。<br>自定义的 Filter 和系统内置的各种 CIFilter，使用起来方式是一样的。我们唯一要做的，就是实现一个符合规范的 CIFilter 的子类。过程大家就是：编写 kernel-&gt;加载 kernel-&gt;设置参数。假设现在编写一个图片翻转的效果大概过程如下：</p>
<p>1.编写kernel脚本,保存为Flip.kernel</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">kernel vec2 mirrorX ( float imageWidth ) </span><br><span class="line">&#123;</span><br><span class="line">  	vec2 currentVec = destCoord();</span><br><span class="line">  	return vec2 ( imageWidth - currentVec.x , currentVec.y ); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>2.加载kernel</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FlipFilterGenerator</span>:<span class="title">NSObject</span>, <span class="title">CIFilterConstructor</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">filter</span><span class="params">(withName name: String)</span></span> -&gt; <span class="type">CIFilter</span>? &#123;</span><br><span class="line">        <span class="keyword">if</span> name == <span class="string">"\(FlipFilter.self)"</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="type">FlipFilter</span>()</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">let</span> flipKernel:<span class="type">CIWarpKernel</span>? = <span class="type">CIWarpKernel</span>(source:<span class="keyword">try</span>! <span class="type">String</span>(contentsOf:<span class="type">Bundle</span>.main.url(forResource: <span class="string">"Flip"</span>, withExtension: <span class="string">"cikernel"</span>)!))</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FlipFilter</span>: <span class="title">CIFilter</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">override</span> <span class="keyword">init</span>() &#123;</span><br><span class="line">        <span class="keyword">super</span>.<span class="keyword">init</span>()</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">required</span> <span class="keyword">init</span>?(coder aDecoder: <span class="type">NSCoder</span>) &#123;</span><br><span class="line">        <span class="built_in">fatalError</span>(<span class="string">"init(coder:) has not been implemented"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">static</span> <span class="function"><span class="keyword">func</span> <span class="title">register</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="type">CIFilter</span>.registerName(<span class="string">"\(FlipFilter.self)"</span>, constructor: <span class="type">FlipFilterGenerator</span>(), classAttributes: [kCIAttributeFilterName:<span class="string">"\(FlipFilter.self)"</span>])</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">setDefaults</span><span class="params">()</span></span> &#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@objc</span> <span class="keyword">var</span> inputImage: <span class="type">CIImage</span>?</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">override</span> <span class="keyword">var</span> outputImage: <span class="type">CIImage</span>? &#123;</span><br><span class="line">        <span class="keyword">guard</span> <span class="keyword">let</span> width = <span class="keyword">self</span>.inputImage?.extent.size.width <span class="keyword">else</span> &#123; <span class="keyword">return</span> <span class="literal">nil</span> &#125;</span><br><span class="line">        <span class="keyword">let</span> result = flipKernel?.apply(extent: inputImage!.extent, roiCallback: &#123; (index, rect) -&gt; <span class="type">CGRect</span> <span class="keyword">in</span></span><br><span class="line">            <span class="keyword">return</span> rect</span><br><span class="line">        &#125;, image: <span class="keyword">self</span>.inputImage!, arguments: [width])</span><br><span class="line">        <span class="keyword">return</span> result</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">override</span> <span class="keyword">var</span> name: <span class="type">String</span> &#123;</span><br><span class="line">        <span class="keyword">get</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"\(FlipFilter.self)"</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">set</span> &#123;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用CIFilter的source构造函数传入着色器代码，然后通过apply()方法传入参数即可执行着色。当然使用之前记得进行注册，这样在使用的时候就可以像使用内置滤镜一样使用了。</p>
<p>但是这里必须着重看一下apply()方法的几个参数<br>extent:要处理的输入图片的区域(称之为DOD ( domain of definition ) )，一般处理的都是原图，并不会改变图像尺寸所以上面传的是inputImage.extent<br>roiCallback:感兴趣的处理区域（ROI ( region of interest )，可以理解为当前处理区域对应的原图区域）处理完后的回调，回调参数index代表图片索引顺序，回调参数rect代表输出图片的区域DOD，但是需要注意在Core Image处理中这个回调会多次调用。这个值通常只要不发生旋转就是当前图片的坐标（如果旋转90°，则返回为CGRect(x: rect.origin.y, y: rect.origin.x, width: rect.size.height, height: rect.size.width)）<br>arguments:着色器函数中需要的参数，按顺序传入。</p>
<p>自定义滤镜调用：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">FlipFilter</span>.register()</span><br><span class="line">        <span class="keyword">guard</span> <span class="keyword">let</span> cgImage = <span class="type">UIImage</span>(named:<span class="string">"CIFilter_Demo_Origin"</span>)?.cgImage <span class="keyword">else</span> &#123; <span class="keyword">return</span> &#125;</span><br><span class="line">        <span class="keyword">let</span> ciImage = <span class="type">CIImage</span>(cgImage: cgImage)</span><br><span class="line">        <span class="keyword">let</span> outputImage = ciImage.applyingFilter(<span class="string">"FlipFilter"</span>)</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">let</span> context = <span class="type">CIContext</span>()</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">let</span> cgImage = context.createCGImage(outputImage, from: ciImage.extent) &#123;</span><br><span class="line">            <span class="keyword">let</span> image = <span class="type">UIImage</span>(cgImage: cgImage)</span><br><span class="line">            <span class="type">UIImageWriteToSavedPhotosAlbum</span>(image, <span class="literal">nil</span>, <span class="literal">nil</span>, <span class="literal">nil</span>)</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>
<p>下面是上图使用翻转滤镜后的效果：</p>
<p><img src="https://i.loli.net/2020/01/12/Y9RW7AqKlP2ykO1.jpg" alt="CIFilter_Demo_Flip"></p>
<p>其实准确的来说实现一个自定义滤镜就是实现一个自定义的CIKernel类，当然这个类本身包括两个子类<strong>CIColorKernel</strong>和<strong>CIWarpKernel</strong>，前者用于图像颜色转化滤镜，而后者用于形变滤镜，如前面的翻转很明显不是一个颜色值的修改就能解决的，必须依赖于形变操作所以继承自CIWarpKernel要简单些。当然如果你的滤镜综合了二者的特点那么直接选择使用<strong>CIKernel</strong>是正确的。至于着色器代码编写使用的是Core Image Kernel Language (CIKL)，它是OpenGL Shading Language (GLSL) 的子集。CIKL 集成了 GLSL 绝大部分的参数类型和内置函数，另外它还添加了一些适应 Core Image 的参数类似和函数。另外编写CIKL需要注意坐标系，它的坐标系从左下角开始而不是UIKit的左上角。</p>
<p>由于篇幅原因关于编写CIKL的具体细节这里不再赘述，感兴趣可以参考<a href="https://developer.apple.com/library/archive/documentation/GraphicsImaging/Conceptual/ImageUnitTutorial/WritingKernels/WritingKernels.html" target="_blank" rel="external">Writing Kernels</a>和<a href="https://developer.apple.com/library/content/documentation/GraphicsImaging/Reference/CIKernelLangRef/Introduction/Introduction.html#//apple_ref/doc/uid/TP40004397-CH1-SW1" target="_blank" rel="external">Core Image Kernel Language Reference</a>，而编写CIKL的工具自然推荐官方的<a href="https://developer.apple.com/download/more/" target="_blank" rel="external">Quartz Composer</a>。</p>
<blockquote>
<p>从前面的演示也可以看到图片在UIImage、CGImage和CIImage之间不停的转化，那么三者之间有什么区别呢？<br>UIImage存在于UIKit中，CGImage存在于Core Graphics中，CIImage存在于Core Image中。前者负责展示和管理图片数据，例如可以使用UIImageView展示、或者绘制到UIView、layer上等，主要在CPU上操作；CGImage表示图像的像素矩阵，每个点都对应了图片的像素信息，主要运行在GPU上；而CIImage包含了创建图片的必要数据，自身并不会渲染成图片，代表了图像的数据或者操作图像的流程（如滤镜），主要运行在GPU上。换句话说对于CIImage的操作并不会进行大量的图片运算，只有要输出图片时才需要转化成图片数据（推荐这一步尽量放到异步线程中操作）。<br>注意：获取一个图片的CIImage类型时请使用CIImage()构造方法创建，请勿直接访问uiImage.ciImage，因为如果一个UIImage不是从CIImage创建是无法获取ciImage的（uiImage.cgImage类似,上面之所以可以直接使用UIImage.cgImage属性是因为它并非从ciImage创建）。反之，如果从ciImage创建UIImage就不推荐使用UIImage的构造方法了，因为这种方式会丢失信息，例如使用UIViewImage显示时会丢失contentMode设置，如果使用上面的代码保存会出现保存失败的情况，推荐的方式则是使用UIContext先生成CGImage，然后从CGImage创建UIImage（总结起来就是UIImage到CGImage明确的情况下可以直接访问cgImage属性，但是cgImage为空则访问ciImage属性再从ciImage创建cgImage，从CGImage转化为UIImage使用构造函数；UIImage到CIImage推荐使用构造函数，也可以使用CGImage从中间过渡，而从CIImage转化为UIImage只能通过CGImage过渡再用构造函数创建）。</p>
</blockquote>
<h2 id="Metal-Shader"><a href="#Metal-Shader" class="headerlink" title="Metal Shader"></a>Metal Shader</h2><p><img src="https://i.loli.net/2020/01/12/xRAGFhHKaS6U5Jb.png" alt="CIKL-MetalShader"></p>
<p>如果你编写过CIKL你会发现这种开发方式很古老，Quartz Composer尽管作为目前开发CIKL最合适的工具但在Xcode7之后几乎没有更新过，尽管有语法高亮但是没有错误调试，更不用说运行时出错的问题（尽管可以使用<strong>+(id)kernelsWithString:(id)arg1 messageLog:(id)arg2</strong>这个私有方法打印kernel中的错误，但是调试依然很麻烦），自身以字符串传入CIKernel类的方式让它天然失去了语法检查。更重要的是这种方式最终要将CIKL片段变成CIKernel必须经过CIKL-&gt;GLSL-&gt;CIKernel-&gt;IL-&gt;GPU识别码-&gt;Render到GPU，如果遇到滤镜链还必须在中间链接Kernel，而这些操作全部在运行时进行。所以首次使用会比较慢（后面使用会缓存），而2017年Metal支持CIKernel则将Kernel的编译提前到了App编译阶段，从而支持了语法检查，大大提高了开发效率和运行效率。</p>
<p>例如前面的滤镜链中使用了一个马赛克风格的滤镜，这里不妨先看一下使用CIKL编写这个滤镜(注意这是一个CIWrapKernel，返回值是变化后的坐标位置)：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">kernel vec2 <span class="title">pixellateKernel</span><span class="params">(<span class="keyword">float</span> radius)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    vec2 positionOfDestPixel, centerPoint;</span><br><span class="line">    positionOfDestPixel = destCoord();</span><br><span class="line">    centerPoint.x = positionOfDestPixel.x - mod(positionOfDestPixel.x, radius * <span class="number">2.0</span>) + radius;</span><br><span class="line">    centerPoint.y = positionOfDestPixel.y - mod(positionOfDestPixel.y, radius * <span class="number">2.0</span>) + radius;</span><br><span class="line"></span><br><span class="line">    return centerPoint;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个CIKL用Metal Shader书写如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="string">"C"</span> &#123;</span><br><span class="line">    <span class="keyword">namespace</span> coreimage &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="function">float2 <span class="title">pixellateMetal</span><span class="params">(<span class="keyword">float</span> radius,destination dest)</span> </span>&#123;</span><br><span class="line">            float2 positionOfDestPixel, centerPoint;</span><br><span class="line">            positionOfDestPixel = dest.coord();</span><br><span class="line">            centerPoint.x = positionOfDestPixel.x - <span class="built_in">fmod</span>(positionOfDestPixel.x, radius * <span class="number">2.0</span>) + radius;</span><br><span class="line">            centerPoint.y = positionOfDestPixel.y - <span class="built_in">fmod</span>(positionOfDestPixel.y, radius * <span class="number">2.0</span>) + radius;</span><br><span class="line">            </span><br><span class="line">            return centerPoint;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当然对应的自定义CIFilter需要做少许调整：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PixellateFilterGenerator</span>:<span class="title">NSObject</span>, <span class="title">CIFilterConstructor</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">filter</span><span class="params">(withName name: String)</span></span> -&gt; <span class="type">CIFilter</span>? &#123;</span><br><span class="line">        <span class="keyword">if</span> name == <span class="string">"\(PixellateFilter.self)"</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="type">PixellateFilter</span>()</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">var</span> pixellateKernel:<span class="type">CIWarpKernel</span>? = &#123;</span><br><span class="line">    <span class="keyword">guard</span> <span class="keyword">let</span> url = <span class="type">Bundle</span>.main.url(forResource: <span class="string">"default"</span>, withExtension: <span class="string">"metallib"</span>) <span class="keyword">else</span> &#123; <span class="keyword">return</span> <span class="literal">nil</span> &#125;</span><br><span class="line">    <span class="keyword">guard</span> <span class="keyword">let</span> data = <span class="keyword">try</span>? <span class="type">Data</span>(contentsOf: url) <span class="keyword">else</span> &#123; <span class="keyword">return</span> <span class="literal">nil</span> &#125;</span><br><span class="line">    <span class="keyword">let</span> kernel = <span class="keyword">try</span>? <span class="type">CIWarpKernel</span>(functionName: <span class="string">"pixellateMetal"</span>, fromMetalLibraryData: data)</span><br><span class="line">    <span class="keyword">return</span> kernel</span><br><span class="line">&#125;()</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PixellateFilter</span>: <span class="title">CIFilter</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">override</span> <span class="keyword">init</span>() &#123;</span><br><span class="line">        <span class="keyword">super</span>.<span class="keyword">init</span>()</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">required</span> <span class="keyword">init</span>?(coder aDecoder: <span class="type">NSCoder</span>) &#123;</span><br><span class="line">        <span class="built_in">fatalError</span>(<span class="string">"init(coder:) has not been implemented"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">static</span> <span class="function"><span class="keyword">func</span> <span class="title">register</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="type">CIFilter</span>.registerName(<span class="string">"\(PixellateFilter.self)"</span>, constructor: <span class="type">PixellateFilterGenerator</span>(), classAttributes: [kCIAttributeFilterName:<span class="string">"\(PixellateFilter.self)"</span>])</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">setDefaults</span><span class="params">()</span></span> &#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@objc</span> <span class="keyword">var</span> inputImage: <span class="type">CIImage</span>?</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@objc</span> <span class="keyword">var</span> radius:<span class="type">CGFloat</span> = <span class="number">5.0</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">override</span> <span class="keyword">var</span> outputImage: <span class="type">CIImage</span>? &#123;</span><br><span class="line">        <span class="keyword">let</span> result = pixellateKernel?.apply(extent: inputImage!.extent, roiCallback: &#123; (index, rect) -&gt; <span class="type">CGRect</span> <span class="keyword">in</span></span><br><span class="line">            <span class="keyword">return</span> rect</span><br><span class="line">        &#125;, image: <span class="keyword">self</span>.inputImage!, arguments: [radius])</span><br><span class="line">        <span class="keyword">return</span> result</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">override</span> <span class="keyword">var</span> name: <span class="type">String</span> &#123;</span><br><span class="line">        <span class="keyword">get</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"\(PixellateFilter.self)"</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">set</span> &#123;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">override</span> <span class="keyword">var</span> attributes: [<span class="type">String</span> : <span class="type">Any</span>] &#123;</span><br><span class="line">        <span class="keyword">get</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> [</span><br><span class="line">                <span class="string">"radius"</span>:[</span><br><span class="line">                    kCIAttributeMin:<span class="number">1</span>,</span><br><span class="line">                    kCIAttributeDefault:<span class="number">5.0</span>,</span><br><span class="line">                    kCIAttributeType:kCIAttributeTypeScalar</span><br><span class="line">                ]</span><br><span class="line">            ]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果说只是像前面一样简单的使用这个滤镜恐怕还无法体现Metal Shader的高性能，不妨把上面应用自定义滤镜后直接保存相册的操作改成一个滑动条在UIImageView直接预览：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">class ViewController: UIViewController &#123;</span><br><span class="line"></span><br><span class="line">    var filter:CIFilter?</span><br><span class="line">    </span><br><span class="line">    override func viewDidLoad() &#123;</span><br><span class="line">        super.viewDidLoad()</span><br><span class="line">        self.view.addSubview(self.imageView)</span><br><span class="line">        self.view.addSubview(sliderBar)</span><br><span class="line">        </span><br><span class="line">        PixellateFilter.register()</span><br><span class="line">        filter = CIFilter(name: &quot;PixellateFilter&quot;)</span><br><span class="line"></span><br><span class="line">        guard let cgImage = UIImage(named: &quot;CIFilter_Demo_Origin&quot;)?.cgImage else &#123; return &#125;</span><br><span class="line">        let ciImage = CIImage(cgImage: cgImage)</span><br><span class="line">        filter?.setValue(ciImage, forKey: kCIInputImageKey)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    @objc func sliderValueChange(_ sender:UISlider) &#123;</span><br><span class="line">        filter?.setValue(sender.value, forKey: &quot;radius&quot;)</span><br><span class="line">        if let outputImage = filter?.outputImage &#123;</span><br><span class="line">            self.imageView.image = UIImage(ciImage: outputImage)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    private lazy var imageView:UIImageView = &#123;</span><br><span class="line">        let temp = UIImageView(frame: CGRect(x: 0.0, y: 0.0, width: Constants.screenSize.width, height: Constants.screenSize.height-60))</span><br><span class="line">        temp.contentMode = .scaleAspectFill</span><br><span class="line">        temp.image = UIImage(named: &quot;CIFilter_Demo_Origin&quot;)</span><br><span class="line">        return temp</span><br><span class="line">    &#125;()</span><br><span class="line">    </span><br><span class="line">    private lazy var sliderBar:UISlider = &#123;</span><br><span class="line">        let temp = UISlider(frame: CGRect(x: 0.0, y: Constants.screenSize.height-50, width: Constants.screenSize.width, height: 30))</span><br><span class="line">        temp.minimumValue = 1</span><br><span class="line">        temp.maximumValue = 20</span><br><span class="line">        temp.addTarget(self, action: #selector(sliderValueChange(_:)), for: UIControl.Event.valueChanged)</span><br><span class="line">        return temp</span><br><span class="line">    &#125;()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行效果：</p>
<p><img src="https://i.loli.net/2020/01/12/yk1elBNduIazH4A.gif" alt="Metal-Shader-Demo"></p>
<p>可以看到，拖动滑动条可以实时预览滤镜效果而没有丝毫卡顿，前面也提到CIImage本身并不包含图像数据，当UIImageView显示时会在GPU上执行Core Image操作，释放了CPU的压力（这也是UIImageView针对Core Image优化的结果）。</p>
<blockquote>
<p>无论是通过CIKL还是通过Metal自定义CIFilter都不是万能的，这是由于kernel本身的限制所造成的。kernel的原理简单理解就是遍历一个图片的所有像素点，然后通过kernel处理后返回新的像素点作为新的图片的像素点。而类似于绘制直方图、动漫风格等操作依赖于整个图片的分布或者依赖于机器学习的操作则很难使用kernel完成，当然这可以借助于后面的OpenCV轻松做到。</p>
</blockquote>
<h1 id="GPUImage"><a href="#GPUImage" class="headerlink" title="GPUImage"></a>GPUImage</h1><p>GPUImage可以说是iOS滤镜开发中多数app的首选，原因在于它不仅高效（从名字就可以看出它运行在GPU上），而且简单（下面三行代码就实现了上面的高斯模糊效果），当然还有它强大的工具属性。它不仅支持实时滤镜预览，还支持视频实时滤镜等。</p>
<p>下面是使用高斯模糊的演示：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">GP<span class="built_in">UImageGaussianBlurFilter</span> * blurFilter = [[GP<span class="built_in">UImageGaussianBlurFilter</span> alloc] init];</span><br><span class="line"> blurFilter.blurRadiusInPixels = <span class="number">2.0</span>;</span><br><span class="line"> <span class="built_in">UIImage</span> * image = [<span class="built_in">UIImage</span> imageNamed:<span class="string">@"CIFilter_Demo_Origin"</span>];</span><br><span class="line"> <span class="built_in">UIImage</span> *blurredImage = [blurFilter imageByFilteringImage:image];</span><br></pre></td></tr></table></figure>
<p>滤镜后的效果：</p>
<p><img src="https://i.loli.net/2020/01/12/aQ18n5r4VclKMq2.jpg" alt="GPUImage_GaussianBlur_Demo"></p>
<blockquote>
<p>不过可以对比之前的效果，发现GPUImage对于高斯模糊的处理包括了边缘的处理，并不需要针对边缘进行重新裁剪。</p>
</blockquote>
<p>当然如果不支持自定义那么GPUImage也谈不上强大，GPUImage 自定义滤镜需要使用 OpenGL 着色语言( GLSL )编写 Fragment Shader（片段着色器），这些其实和自定义Core Image是类似的。</p>
<p>下面演示了使用GPUImage自定义实现一个图片暗角滤镜：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#import <span class="meta-string">&lt;GPUImage/GPUImage.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">VignetteFilter</span> : <span class="title">GPUImageFilter</span></span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">@property</span> (<span class="keyword">nonatomic</span>,<span class="keyword">assign</span>) <span class="built_in">CGPoint</span> center;</span><br><span class="line">    <span class="keyword">@property</span> (<span class="keyword">nonatomic</span>,<span class="keyword">assign</span>) <span class="built_in">CGFloat</span> radius;</span><br><span class="line">    <span class="keyword">@property</span> (<span class="keyword">nonatomic</span>,<span class="keyword">assign</span>) <span class="built_in">CGFloat</span> alpha;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">VignetteFilter</span> </span>&#123;</span><br><span class="line">    GLint centerXUniform,centerYUniform,alphaUniform,radiusUniform;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    - (instancetype)init</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">self</span> = [<span class="keyword">super</span> initWithFragmentShaderFromFile:<span class="string">@"VignetteFilter"</span>];</span><br><span class="line">        <span class="keyword">if</span> (!<span class="keyword">self</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        centerXUniform = [filterProgram uniformIndex:<span class="string">@"centerX"</span>];</span><br><span class="line">        centerYUniform = [filterProgram uniformIndex:<span class="string">@"centerY"</span>];</span><br><span class="line">        alphaUniform = [filterProgram uniformIndex:<span class="string">@"alpha"</span>];</span><br><span class="line">        radiusUniform = [filterProgram uniformIndex:<span class="string">@"radius"</span>];</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">self</span>.alpha = <span class="number">0.5</span>;</span><br><span class="line">        <span class="keyword">self</span>.radius = <span class="number">100</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">self</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    - (<span class="keyword">void</span>)setCenter:(<span class="built_in">CGPoint</span>)center &#123;</span><br><span class="line">        [<span class="keyword">self</span> setFloat:center.x forUniform:centerXUniform program:filterProgram];</span><br><span class="line">        [<span class="keyword">self</span> setFloat:center.y forUniform:centerYUniform program:filterProgram];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    - (<span class="keyword">void</span>)setAlpha:(<span class="built_in">CGFloat</span>)alpha &#123;</span><br><span class="line">        [<span class="keyword">self</span> setFloat:alpha forUniform:alphaUniform program:filterProgram];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    - (<span class="keyword">void</span>)setRadius:(<span class="built_in">CGFloat</span>)radius &#123;</span><br><span class="line">        [<span class="keyword">self</span> setFloat:radius forUniform:radiusUniform program:filterProgram];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
<p>片段着色器代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">uniform highp float alpha;</span><br><span class="line">uniform lowp float radius;</span><br><span class="line">uniform lowp float centerX;</span><br><span class="line">uniform lowp float centerY;</span><br><span class="line">varying highp vec2 textureCoordinate;</span><br><span class="line">uniform sampler2D inputImageTexture;</span><br><span class="line">void main()</span><br><span class="line">&#123;</span><br><span class="line">    highp vec2 centerPoint = vec2(centerX, centerY);</span><br><span class="line">    lowp vec4 textureColor = texture2D(inputImageTexture, textureCoordinate);</span><br><span class="line">    highp float distance = distance(gl_FragCoord.xy, centerPoint);</span><br><span class="line">    highp float darken = 1.0 - (distance / (radius*0.5) * alpha);</span><br><span class="line">    gl_FragColor = vec4(textureColor.rgb*darken,textureColor.a);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>滤镜后的图片</p>
<p><img src="https://i.loli.net/2020/01/12/kTRUOv5yxjYoPXW.gif" alt="GPUImage_Vignette_Demo"></p>
<p>和Core Image不同的是GPUImage使用的并非CIKL而是GLSL(二者均是类C语言)来编写滤镜，优点自然是了解片段着色器就可以无过渡编写滤镜着色代码，无需转化，同时它也是跨平台的。缺点就是iOS 12之后Core Image使用Metal引擎逐渐摒弃了OpenGL，效率则更高（当然GPUImage3已经支持Metal Shader，这样二者就逐渐没有了区别）。</p>
<h1 id="OpenCV"><a href="#OpenCV" class="headerlink" title="OpenCV"></a>OpenCV</h1><p>既然前面提到了OpenGL，那么就离不开另外一个库OpenCV，前者主要用于显示，后者用于运算处理，当然OpenCV默认编译是不支持的GPU加速的，不过胜在它的算法强大，算法速度很快，而且令人兴奋的是3.0以后使用CUDA是可以支持使用GPU运算的。</p>
<p>使用OpenCV实现滤镜更像是使用vImage（存在于Accelerate.framework），不仅可以像上面一样直接基于像素进行处理，还能使用它提供的很多强大算法，同时考虑到自定义算子OpenCV甚至直接暴漏了Filter2D让我们可以直接像编写上面的着色器那样方便的进行卷积操作。</p>
<p>下面使用OpenCV实现一个羽化操作：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;math.h&gt;</span><br><span class="line">#include &lt;opencv/cv.h&gt;</span><br><span class="line">#include &lt;opencv/highgui.h&gt;</span><br><span class="line">#define MAXSIZE (32768)</span><br><span class="line">using namespace cv;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">float mSize = 0.5;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    Mat src = imread("/Users/Kenshin/Downloads/CIFilter_Demo_Origin.jpg",1);</span><br><span class="line">    imshow("src",src);</span><br><span class="line">    int width=src.cols;</span><br><span class="line">    int heigh=src.rows;</span><br><span class="line">    int centerX=width&gt;&gt;1;</span><br><span class="line">    int centerY=heigh&gt;&gt;1;</span><br><span class="line">    </span><br><span class="line">    int maxV=centerX*centerX+centerY*centerY;</span><br><span class="line">    int minV=(int)(maxV*(1-mSize));</span><br><span class="line">    int diff= maxV -minV;</span><br><span class="line">    float ratio = width &gt;heigh ? (float)heigh/(float)width : (float)width/(float)heigh;</span><br><span class="line">    </span><br><span class="line">    Mat img;</span><br><span class="line">    src.copyTo(img);</span><br><span class="line">    </span><br><span class="line">    Scalar avg=mean(src);</span><br><span class="line">    Mat dst(img.size(),CV_8UC3);</span><br><span class="line">    Mat mask1u[3];</span><br><span class="line">    float tmp,r;</span><br><span class="line">    for (int y=0;y&lt;heigh;y++)</span><br><span class="line">    &#123;</span><br><span class="line">        uchar* imgP=img.ptr&lt;uchar&gt;(y);</span><br><span class="line">        uchar* dstP=dst.ptr&lt;uchar&gt;(y);</span><br><span class="line">        for (int x=0;x&lt;width;x++)</span><br><span class="line">        &#123;</span><br><span class="line">            int b=imgP[3*x];</span><br><span class="line">            int g=imgP[3*x+1];</span><br><span class="line">            int r=imgP[3*x+2];</span><br><span class="line">            </span><br><span class="line">            float dx=centerX-x;</span><br><span class="line">            float dy=centerY-y;</span><br><span class="line">            </span><br><span class="line">            if(width &gt; heigh)</span><br><span class="line">                dx= (dx*ratio);</span><br><span class="line">            else</span><br><span class="line">                dy = (dy*ratio);</span><br><span class="line">            </span><br><span class="line">            int dstSq = dx*dx + dy*dy;</span><br><span class="line">            </span><br><span class="line">            float v = ((float) dstSq / diff)*255;</span><br><span class="line">            </span><br><span class="line">            r = (int)(r +v);</span><br><span class="line">            g = (int)(g +v);</span><br><span class="line">            b = (int)(b +v);</span><br><span class="line">            r = (r&gt;255 ? 255 : (r&lt;0? 0 : r));</span><br><span class="line">            g = (g&gt;255 ? 255 : (g&lt;0? 0 : g));</span><br><span class="line">            b = (b&gt;255 ? 255 : (b&lt;0? 0 : b));</span><br><span class="line">            </span><br><span class="line">            dstP[3*x] = (uchar)b;</span><br><span class="line">            dstP[3*x+1] = (uchar)g;</span><br><span class="line">            dstP[3*x+2] = (uchar)r;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    imshow("blur",dst);</span><br><span class="line">    </span><br><span class="line">    waitKey();</span><br><span class="line">    imwrite("/Users/Kenshin/Downloads/blur.jpg",dst);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>没错，这是一段c++代码，但在OC中可以很方便的使用，只要实现一个Wrapper类，将.m改为.mm就可以直接调用c++代码。</p>
<p>下面是羽化后的效果：</p>
<p><img src="https://i.loli.net/2020/01/12/jHAEridWOB165vF.jpg" alt="CIFilter_Demo_EdgeBlur"></p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>从上面可以看到其实开发滤镜选择很多，普通的滤镜使用GPUImage这种基于OpenGL的滤镜效率比较高、可移植性强，缺点当然就是GLSL调试比较难，遇到错误需要反复试验。如果你的App仅仅考虑iOS 11以上的运行环境，自然首推Metal Shading Language，调试方便又高效，尽管GPUImage3已经支持了Metal Shader但是当前还不完善，很多GPUImage有的功能还在待开发阶段当前不建议使用。而OpenCV自然是一把倚天剑，强大的算法，天然的可移植性，但是由于过于强大，不是类似于人脸识别这种复杂的非着色滤镜不推荐使用，当然换句话说一旦遇到机器学习相关（例如CARTOONGAN），高级特效一般非OpenCV莫属。</p>

  </section>

</article>

<section class="read-more">
           
    
               
            <div class="read-more-item">
                <span class="read-more-item-dim">最近的文章</span>
                <h2 class="post-list__post-title post-title"><a href="/2020/02/03/iOS开发tip-图片方向/" title="iOS开发tip-图片方向">iOS开发tip-图片方向</a></h2>
                <p class="excerpt">
                
                
概述相信稍微接触过iOS图片相关操作的同学都遇到过图片旋转的问题，另外使用AVFoundation进行拍照的话就会遇到前后摄像头切换mirror问题就让人更摸不着头脑了。今天就简单和大家聊一下iOS的图片方向问题。
元数据Meta在拍照过程中相机可以旋转到各个方向拍摄，但是最终展示的照片应该都是符
                &hellip;
                </p>
                <div class="post-list__meta"><time datetime="2020-02-03T10:23:20.000Z" class="post-list__meta--date date">2020-02-03</time> &#8226; <span class="post-list__meta--tags tags">于&nbsp;
  <a class="tag-link" href="/tags/UIImageOrientation-Exif/">UIImageOrientation , Exif</a>
</span><a class="btn-border-small" href="/2020/02/03/iOS开发tip-图片方向/">继续阅读</a></div>
                           
            </div>
        
        
               
            <div class="read-more-item">
                <span class="read-more-item-dim">更早的文章</span>
                <h2 class="post-list__post-title post-title"><a href="/2017/06/05/iOS架构设计-URL缓存/" title="iOS架构设计-URL缓存">iOS架构设计-URL缓存</a></h2>
                <p class="excerpt">
                
                概览缓存组件应该说是每个客户端程序必备的核心组件，试想对于每个界面的访问都必须重新请求势必降低用户体验。但是如何处理客户端缓存貌似并没有统一的解决方案，多数开发者选择自行创建数据库直接将服务器端请求的JSON（或Model）缓存起来，下次请求则查询数据库检查缓存是否存在；另外还有些开发者会选择以归档
                &hellip;
                </p>
                <div class="post-list__meta"><time datetime="2017-06-05T07:53:20.000Z" class="post-list__meta--date date">2017-06-05</time> &#8226; <span class="post-list__meta--tags tags">于&nbsp;
  <a class="tag-link" href="/tags/NSURLCache-AlamofireURLCache-NSURLProtocol/">NSURLCache,AlamofireURLCache,NSURLProtocol</a>
</span><a class="btn-border-small" href="/2017/06/05/iOS架构设计-URL缓存/">继续阅读</a></div>
                       
            </div>
        
     
   
   
  
</section>

  
<section class="post-comments">
  <div id="disqus_thread"></div>
  <script type="text/javascript">
      var disqus_shortname = 'kenshincui'; 
      
  var disqus_identifier = '/2020/01/13/iOS滤镜系列-滤镜开发概览/';
  var disqus_title = 'iOS滤镜系列-滤镜开发概览';
  var disqus_url = 'http://yoursite.com/2020/01/13/iOS滤镜系列-滤镜开发概览/';
  

      /* * * DON'T EDIT BELOW THIS LINE * * */
      (function() {
          var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
          //dsq.src = 'https://' + disqus_shortname + '.disqus.com/embed.js';
          dsq.src = 'https://a.disquscdn.com/embed.js';
          (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
      })();
  </script>
  <noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
  <a href="https://disqus.com" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a>
</section>


            <footer class="footer">
    <span class="footer__copyright">
        本站点采用 <a href="http://creativecommons.org/licenses/by-nc-sa/4.0/">知识共享署名-非商业性使用-相同方式共享 4.0 国际许可协议</a>
    </span>
    <span class="footer__copyright">
        基于 <a href="http://hexo.io">Hexo</a> 搭建，感谢 <a href="https://pages.github.com/">GitHub Pages</a> 提供免费的托管服务
    </span>
    <span class="footer__copyright">
        &copy; 2020 - 本站使用 <a href="https://github.com/monniya/hexo-theme-new-vno ">new-vno</a> 主题,
        由<a href="https://monniya.com ">@Monniya</a> 修改自 <a href="https://github.com/lenbo-ma/hexo-theme-vno" target="_blank">Vno</a>, 原创出自<a href="http://github.com/onevcat/vno" target="_blank">onevcat</a>
    </span>
    
</footer>


        </div>
    </div>

     
    


    <script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    
    
</body>
</html>
